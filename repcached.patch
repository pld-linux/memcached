diff -urN --exclude *.m4 memcached-1.4.4/Makefile.am repcached-2.2-1.4.4/Makefile.am
--- memcached-1.4.4/Makefile.am	Fri Oct 30 04:24:52 2009
+++ repcached-2.2-1.4.4/Makefile.am	Tue Feb  9 23:02:45 2010
@@ -31,6 +31,10 @@
 memcached_SOURCES += sasl_defs.c
 endif
 
+if ENABLE_REPLICATION
+memcached_SOURCES += replication.h replication.c
+endif
+
 memcached_debug_SOURCES = $(memcached_SOURCES)
 memcached_CPPFLAGS = -DNDEBUG
 memcached_debug_LDADD = @PROFILER_LDFLAGS@
diff -urN --exclude *.m4 memcached-1.4.4/Makefile.in repcached-2.2-1.4.4/Makefile.in
--- memcached-1.4.4/Makefile.in	Fri Nov 27 09:34:57 2009
+++ repcached-2.2-1.4.4/Makefile.in	Wed Feb 10 19:12:15 2010
@@ -41,13 +41,14 @@
 @BUILD_CACHE_TRUE@am__append_2 = cache.c
 @BUILD_SOLARIS_PRIVS_TRUE@am__append_3 = solaris_priv.c
 @ENABLE_SASL_TRUE@am__append_4 = sasl_defs.c
-@BUILD_DTRACE_TRUE@am__append_5 = memcached_dtrace.h
+@ENABLE_REPLICATION_TRUE@am__append_5 = replication.h replication.c
 @BUILD_DTRACE_TRUE@am__append_6 = memcached_dtrace.h
-@DTRACE_INSTRUMENT_OBJ_TRUE@am__append_7 = memcached_dtrace.o
+@BUILD_DTRACE_TRUE@am__append_7 = memcached_dtrace.h
 @DTRACE_INSTRUMENT_OBJ_TRUE@am__append_8 = memcached_dtrace.o
-@DTRACE_INSTRUMENT_OBJ_TRUE@am__append_9 = memcached_debug_dtrace.o
+@DTRACE_INSTRUMENT_OBJ_TRUE@am__append_9 = memcached_dtrace.o
 @DTRACE_INSTRUMENT_OBJ_TRUE@am__append_10 = memcached_debug_dtrace.o
-@DTRACE_INSTRUMENT_OBJ_TRUE@am__append_11 = memcached_dtrace.o memcached_debug_dtrace.o
+@DTRACE_INSTRUMENT_OBJ_TRUE@am__append_11 = memcached_debug_dtrace.o
+@DTRACE_INSTRUMENT_OBJ_TRUE@am__append_12 = memcached_dtrace.o memcached_debug_dtrace.o
 subdir = .
 DIST_COMMON = README $(am__configure_deps) $(pkginclude_HEADERS) \
 	$(srcdir)/Makefile.am $(srcdir)/Makefile.in \
@@ -70,34 +71,41 @@
 am__memcached_SOURCES_DIST = memcached.c memcached.h hash.c hash.h \
 	slabs.c slabs.h items.c items.h assoc.c assoc.h thread.c \
 	daemon.c stats.c stats.h util.c util.h trace.h cache.h \
-	sasl_defs.h cache.c solaris_priv.c sasl_defs.c
+	sasl_defs.h cache.c solaris_priv.c sasl_defs.c replication.h \
+	replication.c
 @BUILD_CACHE_TRUE@am__objects_1 = memcached-cache.$(OBJEXT)
 @BUILD_SOLARIS_PRIVS_TRUE@am__objects_2 =  \
 @BUILD_SOLARIS_PRIVS_TRUE@	memcached-solaris_priv.$(OBJEXT)
 @ENABLE_SASL_TRUE@am__objects_3 = memcached-sasl_defs.$(OBJEXT)
+@ENABLE_REPLICATION_TRUE@am__objects_4 =  \
+@ENABLE_REPLICATION_TRUE@	memcached-replication.$(OBJEXT)
 am_memcached_OBJECTS = memcached-memcached.$(OBJEXT) \
 	memcached-hash.$(OBJEXT) memcached-slabs.$(OBJEXT) \
 	memcached-items.$(OBJEXT) memcached-assoc.$(OBJEXT) \
 	memcached-thread.$(OBJEXT) memcached-daemon.$(OBJEXT) \
 	memcached-stats.$(OBJEXT) memcached-util.$(OBJEXT) \
-	$(am__objects_1) $(am__objects_2) $(am__objects_3)
+	$(am__objects_1) $(am__objects_2) $(am__objects_3) \
+	$(am__objects_4)
 memcached_OBJECTS = $(am_memcached_OBJECTS)
 am__memcached_debug_SOURCES_DIST = memcached.c memcached.h hash.c \
 	hash.h slabs.c slabs.h items.c items.h assoc.c assoc.h \
 	thread.c daemon.c stats.c stats.h util.c util.h trace.h \
-	cache.h sasl_defs.h cache.c solaris_priv.c sasl_defs.c
-@BUILD_CACHE_TRUE@am__objects_4 = memcached_debug-cache.$(OBJEXT)
-@BUILD_SOLARIS_PRIVS_TRUE@am__objects_5 = memcached_debug-solaris_priv.$(OBJEXT)
-@ENABLE_SASL_TRUE@am__objects_6 = memcached_debug-sasl_defs.$(OBJEXT)
-am__objects_7 = memcached_debug-memcached.$(OBJEXT) \
+	cache.h sasl_defs.h cache.c solaris_priv.c sasl_defs.c \
+	replication.h replication.c
+@BUILD_CACHE_TRUE@am__objects_5 = memcached_debug-cache.$(OBJEXT)
+@BUILD_SOLARIS_PRIVS_TRUE@am__objects_6 = memcached_debug-solaris_priv.$(OBJEXT)
+@ENABLE_SASL_TRUE@am__objects_7 = memcached_debug-sasl_defs.$(OBJEXT)
+@ENABLE_REPLICATION_TRUE@am__objects_8 = memcached_debug-replication.$(OBJEXT)
+am__objects_9 = memcached_debug-memcached.$(OBJEXT) \
 	memcached_debug-hash.$(OBJEXT) memcached_debug-slabs.$(OBJEXT) \
 	memcached_debug-items.$(OBJEXT) \
 	memcached_debug-assoc.$(OBJEXT) \
 	memcached_debug-thread.$(OBJEXT) \
 	memcached_debug-daemon.$(OBJEXT) \
 	memcached_debug-stats.$(OBJEXT) memcached_debug-util.$(OBJEXT) \
-	$(am__objects_4) $(am__objects_5) $(am__objects_6)
-am_memcached_debug_OBJECTS = $(am__objects_7)
+	$(am__objects_5) $(am__objects_6) $(am__objects_7) \
+	$(am__objects_8)
+am_memcached_debug_OBJECTS = $(am__objects_9)
 memcached_debug_OBJECTS = $(am_memcached_debug_OBJECTS)
 memcached_debug_LINK = $(CCLD) $(memcached_debug_CFLAGS) $(CFLAGS) \
 	$(AM_LDFLAGS) $(LDFLAGS) -o $@
@@ -105,8 +113,9 @@
 sizes_OBJECTS = sizes.$(OBJEXT)
 sizes_LDADD = $(LDADD)
 am__testapp_SOURCES_DIST = testapp.c util.c util.h cache.c
-@BUILD_CACHE_TRUE@am__objects_8 = cache.$(OBJEXT)
-am_testapp_OBJECTS = testapp.$(OBJEXT) util.$(OBJEXT) $(am__objects_8)
+@BUILD_CACHE_TRUE@am__objects_10 = cache.$(OBJEXT)
+am_testapp_OBJECTS = testapp.$(OBJEXT) util.$(OBJEXT) \
+	$(am__objects_10)
 testapp_OBJECTS = $(am_testapp_OBJECTS)
 testapp_LDADD = $(LDADD)
 am_timedrun_OBJECTS = timedrun.$(OBJEXT)
@@ -261,21 +270,22 @@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
 pkginclude_HEADERS = protocol_binary.h
-BUILT_SOURCES = $(am__append_5)
+BUILT_SOURCES = $(am__append_6)
 testapp_SOURCES = testapp.c util.c util.h $(am__append_2)
 timedrun_SOURCES = timedrun.c
 memcached_SOURCES = memcached.c memcached.h hash.c hash.h slabs.c \
 	slabs.h items.c items.h assoc.c assoc.h thread.c daemon.c \
 	stats.c stats.h util.c util.h trace.h cache.h sasl_defs.h \
-	$(am__append_1) $(am__append_3) $(am__append_4)
+	$(am__append_1) $(am__append_3) $(am__append_4) \
+	$(am__append_5)
 memcached_debug_SOURCES = $(memcached_SOURCES)
 memcached_CPPFLAGS = -DNDEBUG
-memcached_debug_LDADD = @PROFILER_LDFLAGS@ $(am__append_9)
+memcached_debug_LDADD = @PROFILER_LDFLAGS@ $(am__append_10)
 memcached_debug_CFLAGS = @PROFILER_FLAGS@
-memcached_LDADD = $(am__append_7)
-memcached_DEPENDENCIES = $(am__append_8)
-memcached_debug_DEPENDENCIES = $(am__append_10)
-CLEANFILES = $(am__append_6) $(am__append_11)
+memcached_LDADD = $(am__append_8)
+memcached_DEPENDENCIES = $(am__append_9)
+memcached_debug_DEPENDENCIES = $(am__append_11)
+CLEANFILES = $(am__append_7) $(am__append_12)
 SUBDIRS = doc
 DIST_DIRS = scripts
 EXTRA_DIST = doc scripts t memcached.spec memcached_dtrace.d version.m4
@@ -390,6 +400,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/memcached-hash.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/memcached-items.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/memcached-memcached.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/memcached-replication.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/memcached-sasl_defs.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/memcached-slabs.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/memcached-solaris_priv.Po@am__quote@
@@ -402,6 +413,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/memcached_debug-hash.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/memcached_debug-items.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/memcached_debug-memcached.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/memcached_debug-replication.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/memcached_debug-sasl_defs.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/memcached_debug-slabs.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/memcached_debug-solaris_priv.Po@am__quote@
@@ -595,6 +607,20 @@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(memcached_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o memcached-sasl_defs.obj `if test -f 'sasl_defs.c'; then $(CYGPATH_W) 'sasl_defs.c'; else $(CYGPATH_W) '$(srcdir)/sasl_defs.c'; fi`
 
+memcached-replication.o: replication.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(memcached_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT memcached-replication.o -MD -MP -MF $(DEPDIR)/memcached-replication.Tpo -c -o memcached-replication.o `test -f 'replication.c' || echo '$(srcdir)/'`replication.c
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/memcached-replication.Tpo $(DEPDIR)/memcached-replication.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='replication.c' object='memcached-replication.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(memcached_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o memcached-replication.o `test -f 'replication.c' || echo '$(srcdir)/'`replication.c
+
+memcached-replication.obj: replication.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(memcached_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT memcached-replication.obj -MD -MP -MF $(DEPDIR)/memcached-replication.Tpo -c -o memcached-replication.obj `if test -f 'replication.c'; then $(CYGPATH_W) 'replication.c'; else $(CYGPATH_W) '$(srcdir)/replication.c'; fi`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/memcached-replication.Tpo $(DEPDIR)/memcached-replication.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='replication.c' object='memcached-replication.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(memcached_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o memcached-replication.obj `if test -f 'replication.c'; then $(CYGPATH_W) 'replication.c'; else $(CYGPATH_W) '$(srcdir)/replication.c'; fi`
+
 memcached_debug-memcached.o: memcached.c
 @am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(memcached_debug_CFLAGS) $(CFLAGS) -MT memcached_debug-memcached.o -MD -MP -MF $(DEPDIR)/memcached_debug-memcached.Tpo -c -o memcached_debug-memcached.o `test -f 'memcached.c' || echo '$(srcdir)/'`memcached.c
 @am__fastdepCC_TRUE@	mv -f $(DEPDIR)/memcached_debug-memcached.Tpo $(DEPDIR)/memcached_debug-memcached.Po
@@ -762,6 +788,20 @@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='sasl_defs.c' object='memcached_debug-sasl_defs.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(memcached_debug_CFLAGS) $(CFLAGS) -c -o memcached_debug-sasl_defs.obj `if test -f 'sasl_defs.c'; then $(CYGPATH_W) 'sasl_defs.c'; else $(CYGPATH_W) '$(srcdir)/sasl_defs.c'; fi`
+
+memcached_debug-replication.o: replication.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(memcached_debug_CFLAGS) $(CFLAGS) -MT memcached_debug-replication.o -MD -MP -MF $(DEPDIR)/memcached_debug-replication.Tpo -c -o memcached_debug-replication.o `test -f 'replication.c' || echo '$(srcdir)/'`replication.c
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/memcached_debug-replication.Tpo $(DEPDIR)/memcached_debug-replication.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='replication.c' object='memcached_debug-replication.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(memcached_debug_CFLAGS) $(CFLAGS) -c -o memcached_debug-replication.o `test -f 'replication.c' || echo '$(srcdir)/'`replication.c
+
+memcached_debug-replication.obj: replication.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(memcached_debug_CFLAGS) $(CFLAGS) -MT memcached_debug-replication.obj -MD -MP -MF $(DEPDIR)/memcached_debug-replication.Tpo -c -o memcached_debug-replication.obj `if test -f 'replication.c'; then $(CYGPATH_W) 'replication.c'; else $(CYGPATH_W) '$(srcdir)/replication.c'; fi`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/memcached_debug-replication.Tpo $(DEPDIR)/memcached_debug-replication.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='replication.c' object='memcached_debug-replication.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(memcached_debug_CFLAGS) $(CFLAGS) -c -o memcached_debug-replication.obj `if test -f 'replication.c'; then $(CYGPATH_W) 'replication.c'; else $(CYGPATH_W) '$(srcdir)/replication.c'; fi`
 install-pkgincludeHEADERS: $(pkginclude_HEADERS)
 	@$(NORMAL_INSTALL)
 	test -z "$(pkgincludedir)" || $(MKDIR_P) "$(DESTDIR)$(pkgincludedir)"
diff -urN --exclude *.m4 memcached-1.4.4/assoc.c repcached-2.2-1.4.4/assoc.c
--- memcached-1.4.4/assoc.c	Sat Oct 24 00:38:01 2009
+++ repcached-2.2-1.4.4/assoc.c	Tue Feb  9 23:02:45 2010
@@ -258,3 +258,51 @@
 }
 
 
+#ifdef USE_REPLICATION
+char *assoc_key_snap(int *n)
+{
+    char *p = NULL;
+    char *b = NULL;
+    item *i = NULL;
+    int  co = 0;
+    int  sz = 1;
+    int  hs = 0;
+    int  hm = hashsize(hashpower);
+
+    hs = hm;
+    while(hs--){
+        if(expanding && hs < hashsize(hashpower - 1) && hs >= expand_bucket){
+            i = old_hashtable[hs];
+        }else{
+            i = primary_hashtable[hs];
+        }
+        while(i){
+            sz += i->nkey + 1;
+            co++;
+            i = i->h_next;
+        }
+    }
+
+    if(co){
+        if((p = b = malloc(sz))){
+            hs = hm;
+            while(hs--){
+                if(expanding && hs < hashsize(hashpower - 1) && hs >= expand_bucket){
+                    i = old_hashtable[hs];
+                }else{
+                    i = primary_hashtable[hs];
+                }
+                while(i){
+                    memcpy(p, ITEM_key(i), i->nkey);
+                    p += i->nkey;
+                    *(p++) = 0;
+                    i = i->h_next;
+                }
+            }
+            *(p++) = 0;
+        }
+    }
+    if(n) *n = co;
+    return(b);
+}
+#endif /* USE_REPLICATION */
diff -urN --exclude *.m4 memcached-1.4.4/assoc.h repcached-2.2-1.4.4/assoc.h
--- memcached-1.4.4/assoc.h	Sun Aug 30 03:00:58 2009
+++ repcached-2.2-1.4.4/assoc.h	Tue Feb  9 23:02:45 2010
@@ -7,3 +7,6 @@
 int start_assoc_maintenance_thread(void);
 void stop_assoc_maintenance_thread(void);
 
+#ifdef USE_REPLICATION
+char *assoc_key_snap(int *n);
+#endif /*USE_REPLICATION*/
diff -urN --exclude *.m4 memcached-1.4.4/config.guess repcached-2.2-1.4.4/config.guess
--- memcached-1.4.4/config.guess	Sat Aug 22 04:38:32 2009
+++ repcached-2.2-1.4.4/config.guess	Tue Jan 19 12:34:08 2010
@@ -1,10 +1,9 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
 #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
-#   Free Software Foundation, Inc.
+#   2000, 2001, 2002, 2003 Free Software Foundation, Inc.
 
-timestamp='2008-09-28'
+timestamp='2003-07-02'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -18,15 +17,13 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
-# 02110-1301, USA.
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 #
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
 # the same distribution terms that you use for the rest of that program.
 
-
 # Originally written by Per Bothner <per@bothner.com>.
 # Please send patches to <config-patches@gnu.org>.  Submit a context
 # diff and a properly formatted ChangeLog entry.
@@ -56,8 +53,8 @@
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
-2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
+Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -69,11 +66,11 @@
 while test $# -gt 0 ; do
   case $1 in
     --time-stamp | --time* | -t )
-       echo "$timestamp" ; exit ;;
+       echo "$timestamp" ; exit 0 ;;
     --version | -v )
-       echo "$version" ; exit ;;
+       echo "$version" ; exit 0 ;;
     --help | --h* | -h )
-       echo "$usage"; exit ;;
+       echo "$usage"; exit 0 ;;
     -- )     # Stop option processing
        shift; break ;;
     - )	# Use stdin as input.
@@ -107,7 +104,7 @@
 trap "exitcode=\$?; (rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null) && exit \$exitcode" 0 ;
 trap "rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null; exit 1" 1 2 13 15 ;
 : ${TMPDIR=/tmp} ;
- { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
+ { tmp=`(umask 077 && mktemp -d -q "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
  { test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||
  { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo "Warning: creating insecure temp directory" >&2 ; } ||
  { echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; } ;
@@ -126,7 +123,7 @@
 	;;
  ,,*)   CC_FOR_BUILD=$CC ;;
  ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
-esac ; set_cc_for_build= ;'
+esac ;'
 
 # This is needed to find uname on a Pyramid OSx when run in the BSD universe.
 # (ghazi@noc.rutgers.edu 1994-08-24)
@@ -139,23 +136,6 @@
 UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
 UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
 
-if [ "${UNAME_SYSTEM}" = "Linux" ] ; then
-	eval $set_cc_for_build
-	cat << EOF > $dummy.c
-	#include <features.h>
-	#ifdef __UCLIBC__
-	# ifdef __UCLIBC_CONFIG_VERSION__
-	LIBC=uclibc __UCLIBC_CONFIG_VERSION__
-	# else
-	LIBC=uclibc
-	# endif
-	#else
-	LIBC=gnu
-	#endif
-EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep LIBC= | sed -e 's: ::g'`
-fi
-
 # Note: order is significant - the case branches are not exclusive.
 
 case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
@@ -178,7 +158,6 @@
 	    arm*) machine=arm-unknown ;;
 	    sh3el) machine=shl-unknown ;;
 	    sh3eb) machine=sh-unknown ;;
-	    sh5el) machine=sh5le-unknown ;;
 	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
 	esac
 	# The Operating System including object format, if it has switched
@@ -217,32 +196,50 @@
 	# contains redundant information, the shorter form:
 	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
 	echo "${machine}-${os}${release}"
-	exit ;;
+	exit 0 ;;
+    amiga:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    arc:OpenBSD:*:*)
+	echo mipsel-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    hp300:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mac68k:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    macppc:OpenBSD:*:*)
+	echo powerpc-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mvme68k:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mvme88k:OpenBSD:*:*)
+	echo m88k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mvmeppc:OpenBSD:*:*)
+	echo powerpc-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    pmax:OpenBSD:*:*)
+	echo mipsel-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    sgi:OpenBSD:*:*)
+	echo mipseb-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    sun3:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    wgrisc:OpenBSD:*:*)
+	echo mipsel-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
     *:OpenBSD:*:*)
-	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
-	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
-	exit ;;
-    *:ekkoBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
-	exit ;;
-    *:SolidBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-solidbsd${UNAME_RELEASE}
-	exit ;;
-    macppc:MirBSD:*:*)
-	echo powerpc-unknown-mirbsd${UNAME_RELEASE}
-	exit ;;
-    *:MirBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
-	exit ;;
+	echo ${UNAME_MACHINE}-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
     alpha:OSF1:*:*)
-	case $UNAME_RELEASE in
-	*4.0)
+	if test $UNAME_RELEASE = "V4.0"; then
 		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
-		;;
-	*5.*)
-	        UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
-		;;
-	esac
+	fi
 	# According to Compaq, /usr/sbin/psrinfo has been available on
 	# OSF/1 and Tru64 systems produced since 1995.  I hope that
 	# covers most systems running today.  This code pipes the CPU
@@ -280,49 +277,42 @@
 	    "EV7.9 (21364A)")
 		UNAME_MACHINE="alphaev79" ;;
 	esac
-	# A Pn.n version is a patched version.
 	# A Vn.n version is a released version.
 	# A Tn.n version is a released field test version.
 	# A Xn.n version is an unreleased experimental baselevel.
 	# 1.2 uses "1.2" for uname -r.
-	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-	exit ;;
+	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[VTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+	exit 0 ;;
+    Alpha*:OpenVMS:*:*)
+	echo alpha-hp-vms
+	exit 0 ;;
     Alpha\ *:Windows_NT*:*)
 	# How do we know it's Interix rather than the generic POSIX subsystem?
 	# Should we change UNAME_MACHINE based on the output of uname instead
 	# of the specific Alpha model?
 	echo alpha-pc-interix
-	exit ;;
+	exit 0 ;;
     21064:Windows_NT:50:3)
 	echo alpha-dec-winnt3.5
-	exit ;;
+	exit 0 ;;
     Amiga*:UNIX_System_V:4.0:*)
 	echo m68k-unknown-sysv4
-	exit ;;
+	exit 0;;
     *:[Aa]miga[Oo][Ss]:*:*)
 	echo ${UNAME_MACHINE}-unknown-amigaos
-	exit ;;
+	exit 0 ;;
     *:[Mm]orph[Oo][Ss]:*:*)
 	echo ${UNAME_MACHINE}-unknown-morphos
-	exit ;;
+	exit 0 ;;
     *:OS/390:*:*)
 	echo i370-ibm-openedition
-	exit ;;
-    *:z/VM:*:*)
-	echo s390-ibm-zvmoe
-	exit ;;
-    *:OS400:*:*)
-        echo powerpc-ibm-os400
-	exit ;;
+	exit 0 ;;
     arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
 	echo arm-acorn-riscix${UNAME_RELEASE}
-	exit ;;
-    arm:riscos:*:*|arm:RISCOS:*:*)
-	echo arm-unknown-riscos
-	exit ;;
+	exit 0;;
     SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
 	echo hppa1.1-hitachi-hiuxmpp
-	exit ;;
+	exit 0;;
     Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
 	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
 	if test "`(/bin/universe) 2>/dev/null`" = att ; then
@@ -330,32 +320,32 @@
 	else
 		echo pyramid-pyramid-bsd
 	fi
-	exit ;;
+	exit 0 ;;
     NILE*:*:*:dcosx)
 	echo pyramid-pyramid-svr4
-	exit ;;
+	exit 0 ;;
     DRS?6000:unix:4.0:6*)
 	echo sparc-icl-nx6
-	exit ;;
-    DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
+	exit 0 ;;
+    DRS?6000:UNIX_SV:4.2*:7*)
 	case `/usr/bin/uname -p` in
-	    sparc) echo sparc-icl-nx7; exit ;;
+	    sparc) echo sparc-icl-nx7 && exit 0 ;;
 	esac ;;
     sun4H:SunOS:5.*:*)
 	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit ;;
+	exit 0 ;;
     sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
 	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit ;;
-    i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
+	exit 0 ;;
+    i86pc:SunOS:5.*:*)
 	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit ;;
+	exit 0 ;;
     sun4*:SunOS:6*:*)
 	# According to config.sub, this is the proper way to canonicalize
 	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
 	# it's likely to be more like Solaris than SunOS4.
 	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit ;;
+	exit 0 ;;
     sun4*:SunOS:*:*)
 	case "`/usr/bin/arch -k`" in
 	    Series*|S4*)
@@ -364,10 +354,10 @@
 	esac
 	# Japanese Language versions have a version number like `4.1.3-JL'.
 	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
-	exit ;;
+	exit 0 ;;
     sun3*:SunOS:*:*)
 	echo m68k-sun-sunos${UNAME_RELEASE}
-	exit ;;
+	exit 0 ;;
     sun*:*:4.2BSD:*)
 	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
 	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
@@ -379,10 +369,10 @@
 		echo sparc-sun-sunos${UNAME_RELEASE}
 		;;
 	esac
-	exit ;;
+	exit 0 ;;
     aushp:SunOS:*:*)
 	echo sparc-auspex-sunos${UNAME_RELEASE}
-	exit ;;
+	exit 0 ;;
     # The situation for MiNT is a little confusing.  The machine name
     # can be virtually everything (everything which is not
     # "atarist" or "atariste" at least should have a processor
@@ -393,40 +383,37 @@
     # be no problem.
     atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
         echo m68k-atari-mint${UNAME_RELEASE}
-	exit ;;
+	exit 0 ;;
     atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
 	echo m68k-atari-mint${UNAME_RELEASE}
-        exit ;;
+        exit 0 ;;
     *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
         echo m68k-atari-mint${UNAME_RELEASE}
-	exit ;;
+	exit 0 ;;
     milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
         echo m68k-milan-mint${UNAME_RELEASE}
-        exit ;;
+        exit 0 ;;
     hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
         echo m68k-hades-mint${UNAME_RELEASE}
-        exit ;;
+        exit 0 ;;
     *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
         echo m68k-unknown-mint${UNAME_RELEASE}
-        exit ;;
-    m68k:machten:*:*)
-	echo m68k-apple-machten${UNAME_RELEASE}
-	exit ;;
+        exit 0 ;;
     powerpc:machten:*:*)
 	echo powerpc-apple-machten${UNAME_RELEASE}
-	exit ;;
+	exit 0 ;;
     RISC*:Mach:*:*)
 	echo mips-dec-mach_bsd4.3
-	exit ;;
+	exit 0 ;;
     RISC*:ULTRIX:*:*)
 	echo mips-dec-ultrix${UNAME_RELEASE}
-	exit ;;
+	exit 0 ;;
     VAX*:ULTRIX*:*:*)
 	echo vax-dec-ultrix${UNAME_RELEASE}
-	exit ;;
+	exit 0 ;;
     2020:CLIX:*:* | 2430:CLIX:*:*)
 	echo clipper-intergraph-clix${UNAME_RELEASE}
-	exit ;;
+	exit 0 ;;
     mips:*:*:UMIPS | mips:*:*:RISCos)
 	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
@@ -450,33 +437,32 @@
 	  exit (-1);
 	}
 EOF
-	$CC_FOR_BUILD -o $dummy $dummy.c &&
-	  dummyarg=`echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` &&
-	  SYSTEM_NAME=`$dummy $dummyarg` &&
-	    { echo "$SYSTEM_NAME"; exit; }
+	$CC_FOR_BUILD -o $dummy $dummy.c \
+	  && $dummy `echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` \
+	  && exit 0
 	echo mips-mips-riscos${UNAME_RELEASE}
-	exit ;;
+	exit 0 ;;
     Motorola:PowerMAX_OS:*:*)
 	echo powerpc-motorola-powermax
-	exit ;;
+	exit 0 ;;
     Motorola:*:4.3:PL8-*)
 	echo powerpc-harris-powermax
-	exit ;;
+	exit 0 ;;
     Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
 	echo powerpc-harris-powermax
-	exit ;;
+	exit 0 ;;
     Night_Hawk:Power_UNIX:*:*)
 	echo powerpc-harris-powerunix
-	exit ;;
+	exit 0 ;;
     m88k:CX/UX:7*:*)
 	echo m88k-harris-cxux7
-	exit ;;
+	exit 0 ;;
     m88k:*:4*:R4*)
 	echo m88k-motorola-sysv4
-	exit ;;
+	exit 0 ;;
     m88k:*:3*:R3*)
 	echo m88k-motorola-sysv3
-	exit ;;
+	exit 0 ;;
     AViiON:dgux:*:*)
         # DG/UX returns AViiON for all architectures
         UNAME_PROCESSOR=`/usr/bin/uname -p`
@@ -492,29 +478,29 @@
 	else
 	    echo i586-dg-dgux${UNAME_RELEASE}
 	fi
- 	exit ;;
+ 	exit 0 ;;
     M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
 	echo m88k-dolphin-sysv3
-	exit ;;
+	exit 0 ;;
     M88*:*:R3*:*)
 	# Delta 88k system running SVR3
 	echo m88k-motorola-sysv3
-	exit ;;
+	exit 0 ;;
     XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
 	echo m88k-tektronix-sysv3
-	exit ;;
+	exit 0 ;;
     Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
 	echo m68k-tektronix-bsd
-	exit ;;
+	exit 0 ;;
     *:IRIX*:*:*)
 	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
-	exit ;;
+	exit 0 ;;
     ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
-	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
-	exit ;;               # Note that: echo "'`uname -s`'" gives 'AIX '
+	echo romp-ibm-aix      # uname -m gives an 8 hex-code CPU id
+	exit 0 ;;              # Note that: echo "'`uname -s`'" gives 'AIX '
     i*86:AIX:*:*)
 	echo i386-ibm-aix
-	exit ;;
+	exit 0 ;;
     ia64:AIX:*:*)
 	if [ -x /usr/bin/oslevel ] ; then
 		IBM_REV=`/usr/bin/oslevel`
@@ -522,7 +508,7 @@
 		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
 	fi
 	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
-	exit ;;
+	exit 0 ;;
     *:AIX:2:3)
 	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
 		eval $set_cc_for_build
@@ -537,19 +523,15 @@
 			exit(0);
 			}
 EOF
-		if $CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy`
-		then
-			echo "$SYSTEM_NAME"
-		else
-			echo rs6000-ibm-aix3.2.5
-		fi
+		$CC_FOR_BUILD -o $dummy $dummy.c && $dummy && exit 0
+		echo rs6000-ibm-aix3.2.5
 	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
 		echo rs6000-ibm-aix3.2.4
 	else
 		echo rs6000-ibm-aix3.2
 	fi
-	exit ;;
-    *:AIX:*:[456])
+	exit 0 ;;
+    *:AIX:*:[45])
 	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
 	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
 		IBM_ARCH=rs6000
@@ -562,28 +544,28 @@
 		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
 	fi
 	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
-	exit ;;
+	exit 0 ;;
     *:AIX:*:*)
 	echo rs6000-ibm-aix
-	exit ;;
+	exit 0 ;;
     ibmrt:4.4BSD:*|romp-ibm:BSD:*)
 	echo romp-ibm-bsd4.4
-	exit ;;
+	exit 0 ;;
     ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
 	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
-	exit ;;                             # report: romp-ibm BSD 4.3
+	exit 0 ;;                           # report: romp-ibm BSD 4.3
     *:BOSX:*:*)
 	echo rs6000-bull-bosx
-	exit ;;
+	exit 0 ;;
     DPX/2?00:B.O.S.:*:*)
 	echo m68k-bull-sysv3
-	exit ;;
+	exit 0 ;;
     9000/[34]??:4.3bsd:1.*:*)
 	echo m68k-hp-bsd
-	exit ;;
+	exit 0 ;;
     hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
 	echo m68k-hp-bsd4.4
-	exit ;;
+	exit 0 ;;
     9000/[34678]??:HP-UX:*:*)
 	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
 	case "${UNAME_MACHINE}" in
@@ -645,19 +627,9 @@
 	esac
 	if [ ${HP_ARCH} = "hppa2.0w" ]
 	then
-	    eval $set_cc_for_build
-
-	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
-	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
-	    # generating 64-bit code.  GNU and HP use different nomenclature:
-	    #
-	    # $ CC_FOR_BUILD=cc ./config.guess
-	    # => hppa2.0w-hp-hpux11.23
-	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
-	    # => hppa64-hp-hpux11.23
-
-	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
-		grep __LP64__ >/dev/null
+	    # avoid double evaluation of $set_cc_for_build
+	    test -n "$CC_FOR_BUILD" || eval $set_cc_for_build
+	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E -) | grep __LP64__ >/dev/null
 	    then
 		HP_ARCH="hppa2.0w"
 	    else
@@ -665,11 +637,11 @@
 	    fi
 	fi
 	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
-	exit ;;
+	exit 0 ;;
     ia64:HP-UX:*:*)
 	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
 	echo ia64-hp-hpux${HPUX_REV}
-	exit ;;
+	exit 0 ;;
     3050*:HI-UX:*:*)
 	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
@@ -697,192 +669,153 @@
 	  exit (0);
 	}
 EOF
-	$CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy` &&
-		{ echo "$SYSTEM_NAME"; exit; }
+	$CC_FOR_BUILD -o $dummy $dummy.c && $dummy && exit 0
 	echo unknown-hitachi-hiuxwe2
-	exit ;;
+	exit 0 ;;
     9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
 	echo hppa1.1-hp-bsd
-	exit ;;
+	exit 0 ;;
     9000/8??:4.3bsd:*:*)
 	echo hppa1.0-hp-bsd
-	exit ;;
+	exit 0 ;;
     *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
 	echo hppa1.0-hp-mpeix
-	exit ;;
+	exit 0 ;;
     hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
 	echo hppa1.1-hp-osf
-	exit ;;
+	exit 0 ;;
     hp8??:OSF1:*:*)
 	echo hppa1.0-hp-osf
-	exit ;;
+	exit 0 ;;
     i*86:OSF1:*:*)
 	if [ -x /usr/sbin/sysversion ] ; then
 	    echo ${UNAME_MACHINE}-unknown-osf1mk
 	else
 	    echo ${UNAME_MACHINE}-unknown-osf1
 	fi
-	exit ;;
+	exit 0 ;;
     parisc*:Lites*:*:*)
 	echo hppa1.1-hp-lites
-	exit ;;
+	exit 0 ;;
     C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
 	echo c1-convex-bsd
-        exit ;;
+        exit 0 ;;
     C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
 	if getsysinfo -f scalar_acc
 	then echo c32-convex-bsd
 	else echo c2-convex-bsd
 	fi
-        exit ;;
+        exit 0 ;;
     C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
 	echo c34-convex-bsd
-        exit ;;
+        exit 0 ;;
     C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
 	echo c38-convex-bsd
-        exit ;;
+        exit 0 ;;
     C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
 	echo c4-convex-bsd
-        exit ;;
+        exit 0 ;;
     CRAY*Y-MP:*:*:*)
 	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
+	exit 0 ;;
     CRAY*[A-Z]90:*:*:*)
 	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
 	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
 	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
 	      -e 's/\.[^.]*$/.X/'
-	exit ;;
+	exit 0 ;;
     CRAY*TS:*:*:*)
 	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
+	exit 0 ;;
     CRAY*T3E:*:*:*)
 	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
+	exit 0 ;;
     CRAY*SV1:*:*:*)
 	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
+	exit 0 ;;
     *:UNICOS/mp:*:*)
-	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
+	echo nv1-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/' 
+	exit 0 ;;
     F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
 	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
         FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
         FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
         echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
-        exit ;;
-    5000:UNIX_System_V:4.*:*)
-        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
-        FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
-        echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
-	exit ;;
+        exit 0 ;;
     i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
 	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
-	exit ;;
+	exit 0 ;;
     sparc*:BSD/OS:*:*)
 	echo sparc-unknown-bsdi${UNAME_RELEASE}
-	exit ;;
+	exit 0 ;;
     *:BSD/OS:*:*)
 	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
-	exit ;;
-    *:FreeBSD:*:*)
-	case ${UNAME_MACHINE} in
-	    pc98)
-		echo i386-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
-	    amd64)
-		echo x86_64-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
-	    *)
-		echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
-	esac
-	exit ;;
+	exit 0 ;;
+    *:FreeBSD:*:*|*:GNU/FreeBSD:*:*)
+	# Determine whether the default compiler uses glibc.
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#include <features.h>
+	#if __GLIBC__ >= 2
+	LIBC=gnu
+	#else
+	LIBC=
+	#endif
+EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^LIBC=`
+	# GNU/FreeBSD systems have a "k" prefix to indicate we are using
+	# FreeBSD's kernel, but not the complete OS.
+	case ${LIBC} in gnu) kernel_only='k' ;; esac
+	echo ${UNAME_MACHINE}-unknown-${kernel_only}freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`${LIBC:+-$LIBC}
+	exit 0 ;;
     i*:CYGWIN*:*)
 	echo ${UNAME_MACHINE}-pc-cygwin
-	exit ;;
-    *:MINGW*:*)
+	exit 0 ;;
+    i*:MINGW*:*)
 	echo ${UNAME_MACHINE}-pc-mingw32
-	exit ;;
-    i*:windows32*:*)
-    	# uname -m includes "-pc" on this system.
-    	echo ${UNAME_MACHINE}-mingw32
-	exit ;;
+	exit 0 ;;
     i*:PW*:*)
 	echo ${UNAME_MACHINE}-pc-pw32
-	exit ;;
-    *:Interix*:[3456]*)
-    	case ${UNAME_MACHINE} in
-	    x86)
-		echo i586-pc-interix${UNAME_RELEASE}
-		exit ;;
-	    EM64T | authenticamd | genuineintel)
-		echo x86_64-unknown-interix${UNAME_RELEASE}
-		exit ;;
-	    IA64)
-		echo ia64-unknown-interix${UNAME_RELEASE}
-		exit ;;
-	esac ;;
+	exit 0 ;;
+    x86:Interix*:[34]*)
+	echo i586-pc-interix${UNAME_RELEASE}|sed -e 's/\..*//'
+	exit 0 ;;
     [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
 	echo i${UNAME_MACHINE}-pc-mks
-	exit ;;
+	exit 0 ;;
     i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
 	# How do we know it's Interix rather than the generic POSIX subsystem?
 	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
 	# UNAME_MACHINE based on the output of uname instead of i386?
 	echo i586-pc-interix
-	exit ;;
+	exit 0 ;;
     i*:UWIN*:*)
 	echo ${UNAME_MACHINE}-pc-uwin
-	exit ;;
-    amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
-	echo x86_64-unknown-cygwin
-	exit ;;
+	exit 0 ;;
     p*:CYGWIN*:*)
 	echo powerpcle-unknown-cygwin
-	exit ;;
+	exit 0 ;;
     prep*:SunOS:5.*:*)
 	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit ;;
+	exit 0 ;;
     *:GNU:*:*)
-	# the GNU system
 	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
-	exit ;;
-    *:GNU/*:*:*)
-	# other systems with GNU libc and userland
-	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
-	exit ;;
+	exit 0 ;;
     i*86:Minix:*:*)
 	echo ${UNAME_MACHINE}-pc-minix
-	exit ;;
+	exit 0 ;;
     arm*:Linux:*:*)
-	eval $set_cc_for_build
-	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
-	    | grep -q __ARM_EABI__
-	then
-	    echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
-	else
-	    echo ${UNAME_MACHINE}-unknown-linux-${LIBC}eabi
-	fi
-	exit ;;
-    avr32*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
-	exit ;;
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit 0 ;;
     cris:Linux:*:*)
-	echo cris-axis-linux-${LIBC}
-	exit ;;
-    crisv32:Linux:*:*)
-	echo crisv32-axis-linux-${LIBC}
-	exit ;;
-    frv:Linux:*:*)
-    	echo frv-unknown-linux-${LIBC}
-	exit ;;
+	echo cris-axis-linux-gnu
+	exit 0 ;;
     ia64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
-	exit ;;
-    m32r*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
-	exit ;;
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit 0 ;;
     m68*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
-	exit ;;
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit 0 ;;
     mips:Linux:*:*)
 	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
@@ -899,12 +832,8 @@
 	#endif
 	#endif
 EOF
-	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
-	    /^CPU/{
-		s: ::g
-		p
-	    }'`"
-	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-${LIBC}"; exit; }
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
+	test x"${CPU}" != x && echo "${CPU}-unknown-linux-gnu" && exit 0
 	;;
     mips64:Linux:*:*)
 	eval $set_cc_for_build
@@ -922,22 +851,15 @@
 	#endif
 	#endif
 EOF
-	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
-	    /^CPU/{
-		s: ::g
-		p
-	    }'`"
-	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-${LIBC}"; exit; }
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
+	test x"${CPU}" != x && echo "${CPU}-unknown-linux-gnu" && exit 0
 	;;
-    or32:Linux:*:*)
-	echo or32-unknown-linux-${LIBC}
-	exit ;;
     ppc:Linux:*:*)
-	echo powerpc-unknown-linux-${LIBC}
-	exit ;;
+	echo powerpc-unknown-linux-gnu
+	exit 0 ;;
     ppc64:Linux:*:*)
-	echo powerpc64-unknown-linux-${LIBC}
-	exit ;;
+	echo powerpc64-unknown-linux-gnu
+	exit 0 ;;
     alpha:Linux:*:*)
 	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
 	  EV5)   UNAME_MACHINE=alphaev5 ;;
@@ -949,44 +871,35 @@
 	  EV68*) UNAME_MACHINE=alphaev68 ;;
         esac
 	objdump --private-headers /bin/sh | grep ld.so.1 >/dev/null
-	if test "$?" = 0 ; then LIBC="gnulibc1" ; fi
-	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
-	exit ;;
-    padre:Linux:*:*)
-	echo sparc-unknown-linux-gnu
-	exit ;;
+	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
+	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
+	exit 0 ;;
     parisc:Linux:*:* | hppa:Linux:*:*)
 	# Look for CPU level
 	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
-	  PA7*) echo hppa1.1-unknown-linux-${LIBC} ;;
-	  PA8*) echo hppa2.0-unknown-linux-${LIBC} ;;
-	  *)    echo hppa-unknown-linux-${LIBC} ;;
+	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
+	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
+	  *)    echo hppa-unknown-linux-gnu ;;
 	esac
-	exit ;;
+	exit 0 ;;
     parisc64:Linux:*:* | hppa64:Linux:*:*)
-	echo hppa64-unknown-linux-${LIBC}
-	exit ;;
+	echo hppa64-unknown-linux-gnu
+	exit 0 ;;
     s390:Linux:*:* | s390x:Linux:*:*)
 	echo ${UNAME_MACHINE}-ibm-linux
-	exit ;;
+	exit 0 ;;
     sh64*:Linux:*:*)
-    	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
-	exit ;;
+    	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit 0 ;;
     sh*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
-	exit ;;
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit 0 ;;
     sparc:Linux:*:* | sparc64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
-	exit ;;
-    vax:Linux:*:*)
-	echo ${UNAME_MACHINE}-dec-linux-${LIBC}
-	exit ;;
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit 0 ;;
     x86_64:Linux:*:*)
-	echo x86_64-unknown-linux-${LIBC}
-	exit ;;
-    xtensa*:Linux:*:*)
-    	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
-	exit ;;
+	echo x86_64-unknown-linux-gnu
+	exit 0 ;;
     i*86:Linux:*:*)
 	# The BFD linker knows what the default object file format is, so
 	# first see if it will tell us. cd to the root directory to prevent
@@ -1000,19 +913,20 @@
 				    p'`
         case "$ld_supported_targets" in
 	  elf32-i386)
-		TENTATIVE="${UNAME_MACHINE}-pc-linux-${LIBC}"
+		TENTATIVE="${UNAME_MACHINE}-pc-linux-gnu"
 		;;
 	  a.out-i386-linux)
-		echo "${UNAME_MACHINE}-pc-linux-${LIBC}aout"
-		exit ;;
+		echo "${UNAME_MACHINE}-pc-linux-gnuaout"
+		exit 0 ;;
+	  coff-i386)
+		echo "${UNAME_MACHINE}-pc-linux-gnucoff"
+		exit 0 ;;
 	  "")
 		# Either a pre-BFD a.out linker (linux-gnuoldld) or
 		# one that does not give us useful --help.
-		echo "${UNAME_MACHINE}-pc-linux-${LIBC}oldld"
-		exit ;;
+		echo "${UNAME_MACHINE}-pc-linux-gnuoldld"
+		exit 0 ;;
 	esac
-	# This should get integrated into the C code below, but now we hack
-	if [ "$LIBC" != "gnu" ] ; then echo "$TENTATIVE" && exit 0 ; fi
 	# Determine whether the default compiler is a.out or elf
 	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
@@ -1028,33 +942,23 @@
 	LIBC=gnulibc1
 	# endif
 	#else
-	#if defined(__INTEL_COMPILER) || defined(__PGI) || defined(__SUNPRO_C) || defined(__SUNPRO_CC)
+	#ifdef __INTEL_COMPILER
 	LIBC=gnu
 	#else
 	LIBC=gnuaout
 	#endif
 	#endif
-	#ifdef __dietlibc__
-	LIBC=dietlibc
-	#endif
 EOF
-	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
-	    /^LIBC/{
-		s: ::g
-		p
-	    }'`"
-	test x"${LIBC}" != x && {
-		echo "${UNAME_MACHINE}-pc-linux-${LIBC}"
-		exit
-	}
-	test x"${TENTATIVE}" != x && { echo "${TENTATIVE}"; exit; }
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^LIBC=`
+	test x"${LIBC}" != x && echo "${UNAME_MACHINE}-pc-linux-${LIBC}" && exit 0
+	test x"${TENTATIVE}" != x && echo "${TENTATIVE}" && exit 0
 	;;
     i*86:DYNIX/ptx:4*:*)
 	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
 	# earlier versions are messed up and put the nodename in both
 	# sysname and nodename.
 	echo i386-sequent-sysv4
-	exit ;;
+	exit 0 ;;
     i*86:UNIX_SV:4.2MP:2.*)
         # Unixware is an offshoot of SVR4, but it has its own version
         # number series starting with 2...
@@ -1062,27 +966,24 @@
 	# I just have to hope.  -- rms.
         # Use sysv4.2uw... so that sysv4* matches it.
 	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
-	exit ;;
+	exit 0 ;;
     i*86:OS/2:*:*)
 	# If we were able to find `uname', then EMX Unix compatibility
 	# is probably installed.
 	echo ${UNAME_MACHINE}-pc-os2-emx
-	exit ;;
+	exit 0 ;;
     i*86:XTS-300:*:STOP)
 	echo ${UNAME_MACHINE}-unknown-stop
-	exit ;;
+	exit 0 ;;
     i*86:atheos:*:*)
 	echo ${UNAME_MACHINE}-unknown-atheos
-	exit ;;
-    i*86:syllable:*:*)
-	echo ${UNAME_MACHINE}-pc-syllable
-	exit ;;
+	exit 0 ;;
     i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.0*:*)
 	echo i386-unknown-lynxos${UNAME_RELEASE}
-	exit ;;
+	exit 0 ;;
     i*86:*DOS:*:*)
 	echo ${UNAME_MACHINE}-pc-msdosdjgpp
-	exit ;;
+	exit 0 ;;
     i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
 	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
 	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
@@ -1090,16 +991,15 @@
 	else
 		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
 	fi
-	exit ;;
-    i*86:*:5:[678]*)
-    	# UnixWare 7.x, OpenUNIX and OpenServer 6.
+	exit 0 ;;
+    i*86:*:5:[78]*)
 	case `/bin/uname -X | grep "^Machine"` in
 	    *486*)	     UNAME_MACHINE=i486 ;;
 	    *Pentium)	     UNAME_MACHINE=i586 ;;
 	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
 	esac
 	echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
-	exit ;;
+	exit 0 ;;
     i*86:*:3.2:*)
 	if test -f /usr/options/cb.name; then
 		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
@@ -1117,73 +1017,73 @@
 	else
 		echo ${UNAME_MACHINE}-pc-sysv32
 	fi
-	exit ;;
+	exit 0 ;;
     pc:*:*:*)
 	# Left here for compatibility:
         # uname -m prints for DJGPP always 'pc', but it prints nothing about
         # the processor, so we play safe by assuming i386.
 	echo i386-pc-msdosdjgpp
-        exit ;;
+        exit 0 ;;
     Intel:Mach:3*:*)
 	echo i386-pc-mach3
-	exit ;;
+	exit 0 ;;
     paragon:*:*:*)
 	echo i860-intel-osf1
-	exit ;;
+	exit 0 ;;
     i860:*:4.*:*) # i860-SVR4
 	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
 	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
 	else # Add other i860-SVR4 vendors below as they are discovered.
 	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
 	fi
-	exit ;;
+	exit 0 ;;
     mini*:CTIX:SYS*5:*)
 	# "miniframe"
 	echo m68010-convergent-sysv
-	exit ;;
+	exit 0 ;;
     mc68k:UNIX:SYSTEM5:3.51m)
 	echo m68k-convergent-sysv
-	exit ;;
+	exit 0 ;;
     M680?0:D-NIX:5.3:*)
 	echo m68k-diab-dnix
-	exit ;;
-    M68*:*:R3V[5678]*:*)
-	test -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;
-    3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
+	exit 0 ;;
+    M68*:*:R3V[567]*:*)
+	test -r /sysV68 && echo 'm68k-motorola-sysv' && exit 0 ;;
+    3[34]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0)
 	OS_REL=''
 	test -r /etc/.relid \
 	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
 	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-	  && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
+	  && echo i486-ncr-sysv4.3${OS_REL} && exit 0
 	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
-	  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
+	  && echo i586-ncr-sysv4.3${OS_REL} && exit 0 ;;
     3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
         /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-          && { echo i486-ncr-sysv4; exit; } ;;
+          && echo i486-ncr-sysv4 && exit 0 ;;
     m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
 	echo m68k-unknown-lynxos${UNAME_RELEASE}
-	exit ;;
+	exit 0 ;;
     mc68030:UNIX_System_V:4.*:*)
 	echo m68k-atari-sysv4
-	exit ;;
+	exit 0 ;;
     TSUNAMI:LynxOS:2.*:*)
 	echo sparc-unknown-lynxos${UNAME_RELEASE}
-	exit ;;
+	exit 0 ;;
     rs6000:LynxOS:2.*:*)
 	echo rs6000-unknown-lynxos${UNAME_RELEASE}
-	exit ;;
+	exit 0 ;;
     PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.0*:*)
 	echo powerpc-unknown-lynxos${UNAME_RELEASE}
-	exit ;;
+	exit 0 ;;
     SM[BE]S:UNIX_SV:*:*)
 	echo mips-dde-sysv${UNAME_RELEASE}
-	exit ;;
+	exit 0 ;;
     RM*:ReliantUNIX-*:*:*)
 	echo mips-sni-sysv4
-	exit ;;
+	exit 0 ;;
     RM*:SINIX-*:*:*)
 	echo mips-sni-sysv4
-	exit ;;
+	exit 0 ;;
     *:SINIX-*:*:*)
 	if uname -p 2>/dev/null >/dev/null ; then
 		UNAME_MACHINE=`(uname -p) 2>/dev/null`
@@ -1191,84 +1091,68 @@
 	else
 		echo ns32k-sni-sysv
 	fi
-	exit ;;
+	exit 0 ;;
     PENTIUM:*:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
                       # says <Richard.M.Bartel@ccMail.Census.GOV>
         echo i586-unisys-sysv4
-        exit ;;
+        exit 0 ;;
     *:UNIX_System_V:4*:FTX*)
 	# From Gerald Hewes <hewes@openmarket.com>.
 	# How about differentiating between stratus architectures? -djm
 	echo hppa1.1-stratus-sysv4
-	exit ;;
+	exit 0 ;;
     *:*:*:FTX*)
 	# From seanf@swdc.stratus.com.
 	echo i860-stratus-sysv4
-	exit ;;
-    i*86:VOS:*:*)
-	# From Paul.Green@stratus.com.
-	echo ${UNAME_MACHINE}-stratus-vos
-	exit ;;
+	exit 0 ;;
     *:VOS:*:*)
 	# From Paul.Green@stratus.com.
 	echo hppa1.1-stratus-vos
-	exit ;;
+	exit 0 ;;
     mc68*:A/UX:*:*)
 	echo m68k-apple-aux${UNAME_RELEASE}
-	exit ;;
+	exit 0 ;;
     news*:NEWS-OS:6*:*)
 	echo mips-sony-newsos6
-	exit ;;
+	exit 0 ;;
     R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
 	if [ -d /usr/nec ]; then
 	        echo mips-nec-sysv${UNAME_RELEASE}
 	else
 	        echo mips-unknown-sysv${UNAME_RELEASE}
 	fi
-        exit ;;
+        exit 0 ;;
     BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
 	echo powerpc-be-beos
-	exit ;;
+	exit 0 ;;
     BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
 	echo powerpc-apple-beos
-	exit ;;
+	exit 0 ;;
     BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
 	echo i586-pc-beos
-	exit ;;
-    BePC:Haiku:*:*)	# Haiku running on Intel PC compatible.
-	echo i586-pc-haiku
-	exit ;;
+	exit 0 ;;
     SX-4:SUPER-UX:*:*)
 	echo sx4-nec-superux${UNAME_RELEASE}
-	exit ;;
+	exit 0 ;;
     SX-5:SUPER-UX:*:*)
 	echo sx5-nec-superux${UNAME_RELEASE}
-	exit ;;
+	exit 0 ;;
     SX-6:SUPER-UX:*:*)
 	echo sx6-nec-superux${UNAME_RELEASE}
-	exit ;;
-    SX-7:SUPER-UX:*:*)
-	echo sx7-nec-superux${UNAME_RELEASE}
-	exit ;;
-    SX-8:SUPER-UX:*:*)
-	echo sx8-nec-superux${UNAME_RELEASE}
-	exit ;;
-    SX-8R:SUPER-UX:*:*)
-	echo sx8r-nec-superux${UNAME_RELEASE}
-	exit ;;
+	exit 0 ;;
     Power*:Rhapsody:*:*)
 	echo powerpc-apple-rhapsody${UNAME_RELEASE}
-	exit ;;
+	exit 0 ;;
     *:Rhapsody:*:*)
 	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
-	exit ;;
+	exit 0 ;;
     *:Darwin:*:*)
-	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
-	case $UNAME_PROCESSOR in
-	    unknown) UNAME_PROCESSOR=powerpc ;;
+	case `uname -p` in
+	    *86) UNAME_PROCESSOR=i686 ;;
+	    powerpc) UNAME_PROCESSOR=powerpc ;;
 	esac
 	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
-	exit ;;
+	exit 0 ;;
     *:procnto*:*:* | *:QNX:[0123456789]*:*)
 	UNAME_PROCESSOR=`uname -p`
 	if test "$UNAME_PROCESSOR" = "x86"; then
@@ -1276,25 +1160,22 @@
 		UNAME_MACHINE=pc
 	fi
 	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
-	exit ;;
+	exit 0 ;;
     *:QNX:*:4*)
 	echo i386-pc-qnx
-	exit ;;
-    NSE-?:NONSTOP_KERNEL:*:*)
-	echo nse-tandem-nsk${UNAME_RELEASE}
-	exit ;;
-    NSR-?:NONSTOP_KERNEL:*:*)
+	exit 0 ;;
+    NSR-[DGKLNPTVW]:NONSTOP_KERNEL:*:*)
 	echo nsr-tandem-nsk${UNAME_RELEASE}
-	exit ;;
+	exit 0 ;;
     *:NonStop-UX:*:*)
 	echo mips-compaq-nonstopux
-	exit ;;
+	exit 0 ;;
     BS2000:POSIX*:*:*)
 	echo bs2000-siemens-sysv
-	exit ;;
+	exit 0 ;;
     DS/*:UNIX_System_V:*:*)
 	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
-	exit ;;
+	exit 0 ;;
     *:Plan9:*:*)
 	# "uname -m" is not consistent, so use $cputype instead. 386
 	# is converted to i386 for consistency with other x86
@@ -1305,47 +1186,28 @@
 	    UNAME_MACHINE="$cputype"
 	fi
 	echo ${UNAME_MACHINE}-unknown-plan9
-	exit ;;
+	exit 0 ;;
     *:TOPS-10:*:*)
 	echo pdp10-unknown-tops10
-	exit ;;
+	exit 0 ;;
     *:TENEX:*:*)
 	echo pdp10-unknown-tenex
-	exit ;;
+	exit 0 ;;
     KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
 	echo pdp10-dec-tops20
-	exit ;;
+	exit 0 ;;
     XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
 	echo pdp10-xkl-tops20
-	exit ;;
+	exit 0 ;;
     *:TOPS-20:*:*)
 	echo pdp10-unknown-tops20
-	exit ;;
+	exit 0 ;;
     *:ITS:*:*)
 	echo pdp10-unknown-its
-	exit ;;
+	exit 0 ;;
     SEI:*:*:SEIUX)
         echo mips-sei-seiux${UNAME_RELEASE}
-	exit ;;
-    *:DragonFly:*:*)
-	echo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
-	exit ;;
-    *:*VMS:*:*)
-    	UNAME_MACHINE=`(uname -p) 2>/dev/null`
-	case "${UNAME_MACHINE}" in
-	    A*) echo alpha-dec-vms ; exit ;;
-	    I*) echo ia64-dec-vms ; exit ;;
-	    V*) echo vax-dec-vms ; exit ;;
-	esac ;;
-    *:XENIX:*:SysV)
-	echo i386-pc-xenix
-	exit ;;
-    i*86:skyos:*:*)
-	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
-	exit ;;
-    i*86:rdos:*:*)
-	echo ${UNAME_MACHINE}-pc-rdos
-	exit ;;
+	exit 0 ;;
 esac
 
 #echo '(No uname command or uname output not recognized.)' 1>&2
@@ -1377,7 +1239,7 @@
 #endif
 
 #if defined (__arm) && defined (__acorn) && defined (__unix)
-  printf ("arm-acorn-riscix\n"); exit (0);
+  printf ("arm-acorn-riscix"); exit (0);
 #endif
 
 #if defined (hp300) && !defined (hpux)
@@ -1466,12 +1328,11 @@
 }
 EOF
 
-$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && SYSTEM_NAME=`$dummy` &&
-	{ echo "$SYSTEM_NAME"; exit; }
+$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && $dummy && exit 0
 
 # Apollos put the system type in the environment.
 
-test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }
+test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit 0; }
 
 # Convex versions that predate uname can use getsysinfo(1)
 
@@ -1480,22 +1341,22 @@
     case `getsysinfo -f cpu_type` in
     c1*)
 	echo c1-convex-bsd
-	exit ;;
+	exit 0 ;;
     c2*)
 	if getsysinfo -f scalar_acc
 	then echo c32-convex-bsd
 	else echo c2-convex-bsd
 	fi
-	exit ;;
+	exit 0 ;;
     c34*)
 	echo c34-convex-bsd
-	exit ;;
+	exit 0 ;;
     c38*)
 	echo c38-convex-bsd
-	exit ;;
+	exit 0 ;;
     c4*)
 	echo c4-convex-bsd
-	exit ;;
+	exit 0 ;;
     esac
 fi
 
@@ -1506,9 +1367,7 @@
 the operating system you are using. It is advised that you
 download the most up to date version of the config scripts from
 
-  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
-and
-  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD
+    ftp://ftp.gnu.org/pub/gnu/config/
 
 If the version you run ($0) is already up to date, please
 send the following data and any information you think might be
diff -urN --exclude *.m4 memcached-1.4.4/config.h.in repcached-2.2-1.4.4/config.h.in
--- memcached-1.4.4/config.h.in	Fri Nov 27 09:34:56 2009
+++ repcached-2.2-1.4.4/config.h.in	Wed Feb 10 19:12:46 2010
@@ -99,6 +99,9 @@
 /* Define to 1 if you have the ANSI C header files. */
 #undef STDC_HEADERS
 
+/* Define this if you want to use replication */
+#undef USE_REPLICATION
+
 /* Version number of package */
 #undef VERSION
 
diff -urN --exclude *.m4 memcached-1.4.4/config.sub repcached-2.2-1.4.4/config.sub
--- memcached-1.4.4/config.sub	Sat Aug 22 04:38:32 2009
+++ repcached-2.2-1.4.4/config.sub	Tue Jan 19 12:34:08 2010
@@ -1,10 +1,9 @@
 #! /bin/sh
 # Configuration validation subroutine script.
 #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
-#   Free Software Foundation, Inc.
+#   2000, 2001, 2002, 2003 Free Software Foundation, Inc.
 
-timestamp='2008-09-08'
+timestamp='2003-07-04'
 
 # This file is (in principle) common to ALL GNU software.
 # The presence of a machine in this file suggests that SOME GNU software
@@ -22,15 +21,14 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
-# 02110-1301, USA.
-#
+# Foundation, Inc., 59 Temple Place - Suite 330,
+# Boston, MA 02111-1307, USA.
+
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
 # the same distribution terms that you use for the rest of that program.
 
-
 # Please send patches to <config-patches@gnu.org>.  Submit a context
 # diff and a properly formatted ChangeLog entry.
 #
@@ -72,8 +70,8 @@
 version="\
 GNU config.sub ($timestamp)
 
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
-2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
+Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -85,11 +83,11 @@
 while test $# -gt 0 ; do
   case $1 in
     --time-stamp | --time* | -t )
-       echo "$timestamp" ; exit ;;
+       echo "$timestamp" ; exit 0 ;;
     --version | -v )
-       echo "$version" ; exit ;;
+       echo "$version" ; exit 0 ;;
     --help | --h* | -h )
-       echo "$usage"; exit ;;
+       echo "$usage"; exit 0 ;;
     -- )     # Stop option processing
        shift; break ;;
     - )	# Use stdin as input.
@@ -101,7 +99,7 @@
     *local*)
        # First pass through any local machine types.
        echo $1
-       exit ;;
+       exit 0;;
 
     * )
        break ;;
@@ -120,9 +118,7 @@
 # Here we must recognize all the valid KERNEL-OS combinations.
 maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
 case $maybe_os in
-  nto-qnx* | linux-gnu* | linux-dietlibc | linux-newlib* | linux-uclibc* | \
-  uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* | \
-  storm-chaos* | os2-emx* | rtmk-nova*)
+  nto-qnx* | linux-gnu* | kfreebsd*-gnu* | netbsd*-gnu* | storm-chaos* | os2-emx* | rtmk-nova*)
     os=-$maybe_os
     basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
     ;;
@@ -148,7 +144,7 @@
 	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
 	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
 	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
-	-apple | -axis | -knuth | -cray)
+	-apple | -axis)
 		os=
 		basic_machine=$1
 		;;
@@ -173,10 +169,6 @@
 	-hiux*)
 		os=-hiuxwe2
 		;;
-	-sco6)
-		os=-sco5v6
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
 	-sco5)
 		os=-sco3.2v5
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
@@ -193,10 +185,6 @@
 		# Don't forget version if it is 3.2v4 or newer.
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
-	-sco5v6*)
-		# Don't forget version if it is 3.2v4 or newer.
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
 	-sco*)
 		os=-sco3.2v2
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
@@ -240,55 +228,44 @@
 	| a29k \
 	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
 	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
-	| am33_2.0 \
-	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr | avr32 \
-	| bfin \
+	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr \
 	| c4x | clipper \
-	| d10v | d30v | dlx | dsp16xx | dvp \
-	| fido | fr30 | frv \
+	| d10v | d30v | dlx | dsp16xx \
+	| fr30 | frv \
 	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
 	| i370 | i860 | i960 | ia64 \
-	| ip2k | iq2000 \
-	| m32c | m32r | m32rle | m68000 | m68k | m88k \
-	| maxq | mb | microblaze | mcore | mep | metag \
+	| ip2k \
+	| m32r | m68000 | m68k | m88k | mcore \
 	| mips | mipsbe | mipseb | mipsel | mipsle \
 	| mips16 \
 	| mips64 | mips64el \
-	| mips64octeon | mips64octeonel \
-	| mips64orion | mips64orionel \
-	| mips64r5900 | mips64r5900el \
 	| mips64vr | mips64vrel \
+	| mips64orion | mips64orionel \
 	| mips64vr4100 | mips64vr4100el \
 	| mips64vr4300 | mips64vr4300el \
 	| mips64vr5000 | mips64vr5000el \
-	| mips64vr5900 | mips64vr5900el \
 	| mipsisa32 | mipsisa32el \
 	| mipsisa32r2 | mipsisa32r2el \
 	| mipsisa64 | mipsisa64el \
-	| mipsisa64r2 | mipsisa64r2el \
 	| mipsisa64sb1 | mipsisa64sb1el \
 	| mipsisa64sr71k | mipsisa64sr71kel \
 	| mipstx39 | mipstx39el \
 	| mn10200 | mn10300 \
-	| mt \
 	| msp430 \
-	| nios | nios2 \
 	| ns16k | ns32k \
-	| or32 \
+	| openrisc | or32 \
 	| pdp10 | pdp11 | pj | pjl \
 	| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \
 	| pyramid \
-	| score \
-	| sh | sh[1234] | sh[24]a | sh[24]a*eb | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
+	| sh | sh[1234] | sh[23]e | sh[34]eb | shbe | shle | sh[1234]le | sh3ele \
 	| sh64 | sh64le \
-	| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \
-	| sparcv8 | sparcv9 | sparcv9b | sparcv9v \
-	| spu | strongarm \
+	| sparc | sparc64 | sparc86x | sparclet | sparclite | sparcv9 | sparcv9b \
+	| strongarm \
 	| tahoe | thumb | tic4x | tic80 | tron \
 	| v850 | v850e \
 	| we32k \
-	| x86 | xc16x | xscale | xscalee[bl] | xstormy16 | xtensa \
-	| z8k | z80)
+	| x86 | xscale | xstormy16 | xtensa \
+	| z8k)
 		basic_machine=$basic_machine-unknown
 		;;
 	m6811 | m68hc11 | m6812 | m68hc12)
@@ -298,9 +275,6 @@
 		;;
 	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)
 		;;
-	ms1)
-		basic_machine=mt-unknown
-		;;
 
 	# We use `pc' rather than `unknown'
 	# because (1) that's what they normally are, and
@@ -318,68 +292,56 @@
 	| a29k-* \
 	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
 	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
-	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
+	| alphapca5[67]-* | alpha64pca5[67]-* | amd64-* | arc-* \
 	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
-	| avr-* | avr32-* \
-	| bfin-* | bs2000-* \
+	| avr-* \
+	| bs2000-* \
 	| c[123]* | c30-* | [cjt]90-* | c4x-* | c54x-* | c55x-* | c6x-* \
-	| clipper-* | craynv-* | cydra-* \
+	| clipper-* | cydra-* \
 	| d10v-* | d30v-* | dlx-* \
 	| elxsi-* \
-	| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \
+	| f30[01]-* | f700-* | fr30-* | frv-* | fx80-* \
 	| h8300-* | h8500-* \
 	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
 	| i*86-* | i860-* | i960-* | ia64-* \
-	| ip2k-* | iq2000-* \
-	| m32c-* | m32r-* | m32rle-* \
+	| ip2k-* \
+	| m32r-* \
 	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
-	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* \
+	| m88110-* | m88k-* | mcore-* \
 	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
 	| mips16-* \
 	| mips64-* | mips64el-* \
-	| mips64octeon-* | mips64octeonel-* \
-	| mips64orion-* | mips64orionel-* \
-	| mips64r5900-* | mips64r5900el-* \
 	| mips64vr-* | mips64vrel-* \
+	| mips64orion-* | mips64orionel-* \
 	| mips64vr4100-* | mips64vr4100el-* \
 	| mips64vr4300-* | mips64vr4300el-* \
 	| mips64vr5000-* | mips64vr5000el-* \
-	| mips64vr5900-* | mips64vr5900el-* \
 	| mipsisa32-* | mipsisa32el-* \
 	| mipsisa32r2-* | mipsisa32r2el-* \
 	| mipsisa64-* | mipsisa64el-* \
-	| mipsisa64r2-* | mipsisa64r2el-* \
 	| mipsisa64sb1-* | mipsisa64sb1el-* \
 	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
 	| mipstx39-* | mipstx39el-* \
-	| mmix-* \
-	| mt-* \
 	| msp430-* \
-	| nios-* | nios2-* \
-	| none-* | np1-* | ns16k-* | ns32k-* \
+	| none-* | np1-* | nv1-* | ns16k-* | ns32k-* \
 	| orion-* \
 	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
 	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \
 	| pyramid-* \
 	| romp-* | rs6000-* \
-	| sh-* | sh[1234]-* | sh[24]a-* | sh[24]a*eb-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
+	| sh-* | sh[1234]-* | sh[23]e-* | sh[34]eb-* | shbe-* \
 	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
-	| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \
-	| sparclite-* \
-	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | strongarm-* | sv1-* | sx?-* \
+	| sparc-* | sparc64-* | sparc86x-* | sparclet-* | sparclite-* \
+	| sparcv9-* | sparcv9b-* | strongarm-* | sv1-* | sx?-* \
 	| tahoe-* | thumb-* \
-	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* | tile-* \
+	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
 	| tron-* \
 	| v850-* | v850e-* | vax-* \
 	| we32k-* \
-	| x86-* | x86_64-* | xc16x-* | xps100-* | xscale-* | xscalee[bl]-* \
-	| xstormy16-* | xtensa*-* \
+	| x86-* | x86_64-* | xps100-* | xscale-* | xstormy16-* \
+	| xtensa-* \
 	| ymp-* \
-	| z8k-* | z80-*)
-		;;
-	# Recognize the basic CPU types without company name, with glob match.
-	xtensa*)
-		basic_machine=$basic_machine-unknown
+	| z8k-*)
 		;;
 	# Recognize the various machine names and aliases which stand
 	# for a CPU type and a company and sometimes even an OS.
@@ -397,9 +359,6 @@
 		basic_machine=a29k-amd
 		os=-udi
 		;;
-    	abacus)
-		basic_machine=abacus-unknown
-		;;
 	adobe68k)
 		basic_machine=m68010-adobe
 		os=-scout
@@ -417,9 +376,6 @@
 	amd64)
 		basic_machine=x86_64-pc
 		;;
-	amd64-*)
-		basic_machine=x86_64-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
 	amdahl)
 		basic_machine=580-amdahl
 		os=-sysv
@@ -451,22 +407,10 @@
 		basic_machine=ns32k-sequent
 		os=-dynix
 		;;
-	blackfin)
-		basic_machine=bfin-unknown
-		os=-linux
-		;;
-	blackfin-*)
-		basic_machine=bfin-`echo $basic_machine | sed 's/^[^-]*-//'`
-		os=-linux
-		;;
 	c90)
 		basic_machine=c90-cray
 		os=-unicos
 		;;
-        cegcc)
-		basic_machine=arm-unknown
-		os=-cegcc
-		;;
 	convex-c1)
 		basic_machine=c1-convex
 		os=-bsd
@@ -491,27 +435,12 @@
 		basic_machine=j90-cray
 		os=-unicos
 		;;
-	craynv)
-		basic_machine=craynv-cray
-		os=-unicosmp
-		;;
-	cr16)
-		basic_machine=cr16-unknown
-		os=-elf
-		;;
 	crds | unos)
 		basic_machine=m68k-crds
 		;;
-	crisv32 | crisv32-* | etraxfs*)
-		basic_machine=crisv32-axis
-		;;
 	cris | cris-* | etrax*)
 		basic_machine=cris-axis
 		;;
-	crx)
-		basic_machine=crx-unknown
-		os=-elf
-		;;
 	da30 | da30-*)
 		basic_machine=m68k-da30
 		;;
@@ -534,14 +463,6 @@
 		basic_machine=m88k-motorola
 		os=-sysv3
 		;;
-	dicos)
-		basic_machine=i686-pc
-		os=-dicos
-		;;
-	djgpp)
-		basic_machine=i586-pc
-		os=-msdosdjgpp
-		;;
 	dpx20 | dpx20-*)
 		basic_machine=rs6000-bull
 		os=-bosx
@@ -692,14 +613,6 @@
 		basic_machine=m68k-isi
 		os=-sysv
 		;;
-	m68knommu)
-		basic_machine=m68k-unknown
-		os=-linux
-		;;
-	m68knommu-*)
-		basic_machine=m68k-`echo $basic_machine | sed 's/^[^-]*-//'`
-		os=-linux
-		;;
 	m88k-omron*)
 		basic_machine=m88k-omron
 		;;
@@ -715,10 +628,6 @@
 		basic_machine=i386-pc
 		os=-mingw32
 		;;
-	mingw32ce)
-		basic_machine=arm-unknown
-		os=-mingw32ce
-		;;
 	miniframe)
 		basic_machine=m68000-convergent
 		;;
@@ -726,30 +635,16 @@
 		basic_machine=m68k-atari
 		os=-mint
 		;;
-	mipsEE* | ee | ps2)
-		basic_machine=mips64r5900el-scei
-		case $os in
-		    -linux*)
-			;;
-		    *)
-			os=-elf
-			;;
-		esac
-		;;
-	iop)
-		basic_machine=mipsel-scei
-		os=-irx
-		;;
-	dvp)
-		basic_machine=dvp-scei
-		os=-elf
-		;;
 	mips3*-*)
 		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
 		;;
 	mips3*)
 		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
 		;;
+	mmix*)
+		basic_machine=mmix-knuth
+		os=-mmixware
+		;;
 	monitor)
 		basic_machine=m68k-rom68k
 		os=-coff
@@ -762,9 +657,6 @@
 		basic_machine=i386-pc
 		os=-msdos
 		;;
-	ms1-*)
-		basic_machine=`echo $basic_machine | sed -e 's/ms1-/mt-/'`
-		;;
 	mvs)
 		basic_machine=i370-ibm
 		os=-mvs
@@ -833,6 +725,10 @@
 	np1)
 		basic_machine=np1-gould
 		;;
+	nv1)
+		basic_machine=nv1-cray
+		os=-unicosmp
+		;;
 	nsr-tandem)
 		basic_machine=nsr-tandem
 		;;
@@ -840,12 +736,9 @@
 		basic_machine=hppa1.1-oki
 		os=-proelf
 		;;
-	openrisc | openrisc-*)
+	or32 | or32-*)
 		basic_machine=or32-unknown
-		;;
-	os400)
-		basic_machine=powerpc-ibm
-		os=-os400
+		os=-coff
 		;;
 	OSE68000 | ose68000)
 		basic_machine=m68000-ericsson
@@ -863,14 +756,6 @@
 		basic_machine=i860-intel
 		os=-osf
 		;;
-	parisc)
-		basic_machine=hppa-unknown
-		os=-linux
-		;;
-	parisc-*)
-		basic_machine=hppa-`echo $basic_machine | sed 's/^[^-]*-//'`
-		os=-linux
-		;;
 	pbd)
 		basic_machine=sparc-tti
 		;;
@@ -880,12 +765,6 @@
 	pc532 | pc532-*)
 		basic_machine=ns32k-pc532
 		;;
-	pc98)
-		basic_machine=i386-pc
-		;;
-	pc98-*)
-		basic_machine=i386-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
 	pentium | p5 | k5 | k6 | nexgen | viac3)
 		basic_machine=i586-pc
 		;;
@@ -942,10 +821,6 @@
 		basic_machine=i586-unknown
 		os=-pw32
 		;;
-	rdos)
-		basic_machine=i386-pc
-		os=-rdos
-		;;
 	rom68k)
 		basic_machine=m68k-rom68k
 		os=-coff
@@ -972,10 +847,6 @@
 	sb1el)
 		basic_machine=mipsisa64sb1el-unknown
 		;;
-	sde)
-		basic_machine=mipsisa32-sde
-		os=-elf
-		;;
 	sei)
 		basic_machine=mips-sei
 		os=-seiux
@@ -987,9 +858,6 @@
 		basic_machine=sh-hitachi
 		os=-hms
 		;;
-	sh5el)
-		basic_machine=sh5le-unknown
-		;;
 	sh64)
 		basic_machine=sh64-unknown
 		;;
@@ -1079,10 +947,6 @@
 		basic_machine=tic6x-unknown
 		os=-coff
 		;;
-	tile*)
-		basic_machine=tile-unknown
-		os=-linux-gnu
-		;;
 	tx39)
 		basic_machine=mipstx39-unknown
 		;;
@@ -1096,10 +960,6 @@
 	tower | tower-32)
 		basic_machine=m68k-ncr
 		;;
-	tpf)
-		basic_machine=s390x-ibm
-		os=-tpf
-		;;
 	udi29k)
 		basic_machine=a29k-amd
 		os=-udi
@@ -1143,10 +1003,6 @@
 		basic_machine=hppa1.1-winbond
 		os=-proelf
 		;;
-	xbox)
-		basic_machine=i686-pc
-		os=-mingw32
-		;;
 	xps | xps100)
 		basic_machine=xps100-honeywell
 		;;
@@ -1158,10 +1014,6 @@
 		basic_machine=z8k-unknown
 		os=-sim
 		;;
-	z80-*-coff)
-		basic_machine=z80-unknown
-		os=-sim
-		;;
 	none)
 		basic_machine=none-none
 		os=-none
@@ -1181,9 +1033,6 @@
 	romp)
 		basic_machine=romp-ibm
 		;;
-	mmix)
-		basic_machine=mmix-knuth
-		;;
 	rs6000)
 		basic_machine=rs6000-ibm
 		;;
@@ -1200,10 +1049,13 @@
 	we32k)
 		basic_machine=we32k-att
 		;;
-	sh[1234] | sh[24]a | sh[34]eb | sh[1234]le | sh[23]ele)
+	sh3 | sh4 | sh[34]eb | sh[1234]le | sh[23]ele)
 		basic_machine=sh-unknown
 		;;
-	sparc | sparcv8 | sparcv9 | sparcv9b | sparcv9v)
+	sh64)
+		basic_machine=sh64-unknown
+		;;
+	sparc | sparcv9 | sparcv9b)
 		basic_machine=sparc-sun
 		;;
 	cydra)
@@ -1276,23 +1128,19 @@
 	      | -aos* \
 	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
 	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
-	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
-	      | -openbsd* | -solidbsd* \
-	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
-	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
+	      | -hiux* | -386bsd* | -netbsd* | -openbsd* | -kfreebsd* | -freebsd* | -riscix* \
+	      | -lynxos* | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
 	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
 	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
-	      | -chorusos* | -chorusrdb* | -cegcc* \
+	      | -chorusos* | -chorusrdb* \
 	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
-	      | -mingw32* | -linux-gnu* | -linux-newlib* | -linux-uclibc* \
-	      | -uxpv* | -beos* | -mpeix* | -udk* \
+	      | -mingw32* | -linux-gnu* | -uxpv* | -beos* | -mpeix* | -udk* \
 	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
 	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
 	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
 	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
 	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
-	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
-	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -irx*)
+	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
 	-qnx*)
@@ -1310,15 +1158,12 @@
 		os=`echo $os | sed -e 's|nto|nto-qnx|'`
 		;;
 	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
-	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* | -haiku* \
+	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* \
 	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
 		;;
 	-mac*)
 		os=`echo $os | sed -e 's|mac|macos|'`
 		;;
-	-linux-dietlibc)
-		os=-linux-dietlibc
-		;;
 	-linux*)
 		os=`echo $os | sed -e 's|linux|linux-gnu|'`
 		;;
@@ -1331,9 +1176,6 @@
 	-opened*)
 		os=-openedition
 		;;
-        -os400*)
-		os=-os400
-		;;
 	-wince*)
 		os=-wince
 		;;
@@ -1355,9 +1197,6 @@
 	-atheos*)
 		os=-atheos
 		;;
-	-syllable*)
-		os=-syllable
-		;;
 	-386bsd)
 		os=-bsd
 		;;
@@ -1380,9 +1219,6 @@
 	-sinix*)
 		os=-sysv4
 		;;
-        -tpf*)
-		os=-tpf
-		;;
 	-triton*)
 		os=-sysv3
 		;;
@@ -1419,12 +1255,6 @@
 	-kaos*)
 		os=-kaos
 		;;
-	-zvmoe)
-		os=-zvmoe
-		;;
-	-dicos*)
-		os=-dicos
-		;;
 	-none)
 		;;
 	*)
@@ -1447,12 +1277,6 @@
 # system, and we'll never get to this point.
 
 case $basic_machine in
-        score-*)
-		os=-elf
-		;;
-        spu-*)
-		os=-elf
-		;;
 	*-acorn)
 		os=-riscix1.2
 		;;
@@ -1462,9 +1286,9 @@
 	arm*-semi)
 		os=-aout
 		;;
-        c4x-* | tic4x-*)
-        	os=-coff
-		;;
+    c4x-* | tic4x-*)
+        os=-coff
+        ;;
 	# This must come before the *-dec entry.
 	pdp10-*)
 		os=-tops20
@@ -1490,9 +1314,6 @@
 	m68*-cisco)
 		os=-aout
 		;;
-        mep-*)
-		os=-elf
-		;;
 	mips*-cisco)
 		os=-elf
 		;;
@@ -1511,15 +1332,9 @@
 	*-be)
 		os=-beos
 		;;
-	*-haiku)
-		os=-haiku
-		;;
 	*-ibm)
 		os=-aix
 		;;
-    	*-knuth)
-		os=-mmixware
-		;;
 	*-wec)
 		os=-proelf
 		;;
@@ -1652,15 +1467,9 @@
 			-mvs* | -opened*)
 				vendor=ibm
 				;;
-			-os400*)
-				vendor=ibm
-				;;
 			-ptx*)
 				vendor=sequent
 				;;
-			-tpf*)
-				vendor=ibm
-				;;
 			-vxsim* | -vxworks* | -windiss*)
 				vendor=wrs
 				;;
@@ -1685,7 +1494,7 @@
 esac
 
 echo $basic_machine$os
-exit
+exit 0
 
 # Local variables:
 # eval: (add-hook 'write-file-hooks 'time-stamp)
diff -urN --exclude *.m4 memcached-1.4.4/configure repcached-2.2-1.4.4/configure
--- memcached-1.4.4/configure	Fri Nov 27 09:34:57 2009
+++ repcached-2.2-1.4.4/configure	Wed Feb 10 19:12:16 2010
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.63 for memcached 1.4.4.
+# Generated by GNU Autoconf 2.63 for memcached 1.4.4_49_g6b6b7ed.
 #
 # Report bugs to <brad@danga.com>.
 #
@@ -596,8 +596,8 @@
 # Identity of this package.
 PACKAGE_NAME='memcached'
 PACKAGE_TARNAME='memcached'
-PACKAGE_VERSION='1.4.4'
-PACKAGE_STRING='memcached 1.4.4'
+PACKAGE_VERSION='1.4.4_49_g6b6b7ed'
+PACKAGE_STRING='memcached 1.4.4_49_g6b6b7ed'
 PACKAGE_BUGREPORT='brad@danga.com'
 
 ac_unique_file="memcached.c"
@@ -647,6 +647,8 @@
 BUILD_CACHE_TRUE
 BUILD_SOLARIS_PRIVS_FALSE
 BUILD_SOLARIS_PRIVS_TRUE
+ENABLE_REPLICATION_FALSE
+ENABLE_REPLICATION_TRUE
 PROFILER_FLAGS
 PROFILER
 PROFILER_LDFLAGS
@@ -759,6 +761,7 @@
 enable_coverage
 enable_64bit
 with_libevent
+enable_replication
 enable_docs
 '
       ac_precious_vars='build_alias
@@ -1322,7 +1325,7 @@
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures memcached 1.4.4 to adapt to many kinds of systems.
+\`configure' configures memcached 1.4.4_49_g6b6b7ed to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1393,7 +1396,7 @@
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of memcached 1.4.4:";;
+     short | recursive ) echo "Configuration of memcached 1.4.4_49_g6b6b7ed:";;
    esac
   cat <<\_ACEOF
 
@@ -1407,6 +1410,7 @@
   --enable-dtrace         Enable dtrace probes
   --disable-coverage      Disable code coverage
   --enable-64bit          build 64bit version
+  --enable-replication    support replication
   --disable-docs          Disable documentation generation
 
 Optional Packages:
@@ -1490,7 +1494,7 @@
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-memcached configure 1.4.4
+memcached configure 1.4.4_49_g6b6b7ed
 generated by GNU Autoconf 2.63
 
 Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
@@ -1504,7 +1508,7 @@
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by memcached $as_me 1.4.4, which was
+It was created by memcached $as_me 1.4.4_49_g6b6b7ed, which was
 generated by GNU Autoconf 2.63.  Invocation command line was
 
   $ $0 $@
@@ -2347,7 +2351,7 @@
 
 # Define the identity of the package.
  PACKAGE=memcached
- VERSION=1.4.4
+ VERSION=1.4.4_49_g6b6b7ed
 
 
 cat >>confdefs.h <<_ACEOF
@@ -6798,6 +6802,32 @@
    { (exit 1); exit 1; }; }
 fi
 
+# Check whether --enable-replication was given.
+if test "${enable_replication+set}" = set; then
+  enableval=$enable_replication; if test "x$enable_threads" = "xyes"; then
+     { { $as_echo "$as_me:$LINENO: error: Can't enable threads and replication together." >&5
+$as_echo "$as_me: error: Can't enable threads and replication together." >&2;}
+   { (exit 1); exit 1; }; }
+   else
+
+cat >>confdefs.h <<\_ACEOF
+#define USE_REPLICATION /**/
+_ACEOF
+
+   fi
+
+fi
+
+
+ if test "x$enable_replication" = "xyes"; then
+  ENABLE_REPLICATION_TRUE=
+  ENABLE_REPLICATION_FALSE='#'
+else
+  ENABLE_REPLICATION_TRUE='#'
+  ENABLE_REPLICATION_FALSE=
+fi
+
+
 
 for ac_func in mlockall
 do
@@ -7969,6 +7999,13 @@
 Usually this means the macro was only invoked conditionally." >&2;}
    { (exit 1); exit 1; }; }
 fi
+if test -z "${ENABLE_REPLICATION_TRUE}" && test -z "${ENABLE_REPLICATION_FALSE}"; then
+  { { $as_echo "$as_me:$LINENO: error: conditional \"ENABLE_REPLICATION\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+$as_echo "$as_me: error: conditional \"ENABLE_REPLICATION\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
 if test -z "${BUILD_SOLARIS_PRIVS_TRUE}" && test -z "${BUILD_SOLARIS_PRIVS_FALSE}"; then
   { { $as_echo "$as_me:$LINENO: error: conditional \"BUILD_SOLARIS_PRIVS\" was never defined.
 Usually this means the macro was only invoked conditionally." >&5
@@ -8312,7 +8349,7 @@
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by memcached $as_me 1.4.4, which was
+This file was extended by memcached $as_me 1.4.4_49_g6b6b7ed, which was
 generated by GNU Autoconf 2.63.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -8375,7 +8412,7 @@
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_version="\\
-memcached config.status 1.4.4
+memcached config.status 1.4.4_49_g6b6b7ed
 configured by $0, generated by GNU Autoconf 2.63,
   with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
diff -urN --exclude *.m4 memcached-1.4.4/configure.ac repcached-2.2-1.4.4/configure.ac
--- memcached-1.4.4/configure.ac	Wed Nov 25 03:40:29 2009
+++ repcached-2.2-1.4.4/configure.ac	Tue Feb  9 23:02:45 2010
@@ -382,6 +382,18 @@
   AC_MSG_ERROR([Can't enable threads without the POSIX thread library.])
 fi
 
+dnl Check whether the user wants replication or not
+AC_ARG_ENABLE(replication,
+  [AS_HELP_STRING([--enable-replication],[support replication])],
+  [if test "x$enable_threads" = "xyes"; then
+     AC_MSG_ERROR([Can't enable threads and replication together.])
+   else
+     AC_DEFINE([USE_REPLICATION],,[Define this if you want to use replication])
+   fi
+  ])
+
+AM_CONDITIONAL(ENABLE_REPLICATION, test "x$enable_replication" = "xyes")
+
 AC_CHECK_FUNCS(mlockall)
 AC_CHECK_FUNCS(getpagesizes)
 AC_CHECK_FUNCS(memcntl)
diff -urN --exclude *.m4 memcached-1.4.4/doc/Makefile repcached-2.2-1.4.4/doc/Makefile
--- memcached-1.4.4/doc/Makefile	Fri Nov 27 09:35:03 2009
+++ repcached-2.2-1.4.4/doc/Makefile	Wed Feb 10 19:12:43 2010
@@ -29,9 +29,9 @@
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-build_triplet = x86_64-unknown-linux-gnu
-host_triplet = x86_64-unknown-linux-gnu
-target_triplet = x86_64-unknown-linux-gnu
+build_triplet = i386-unknown-freebsd6.2
+host_triplet = i386-unknown-freebsd6.2
+target_triplet = i386-unknown-freebsd6.2
 #am__append_1 = protocol-binary.txt protocol-binary-range.txt
 subdir = doc
 DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
@@ -50,17 +50,17 @@
 NROFF = nroff
 MANS = $(man_MANS)
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-ACLOCAL = ${SHELL} /home/dormando/p/danga/memcached_github_new/missing --run aclocal-1.10
-AMTAR = ${SHELL} /home/dormando/p/danga/memcached_github_new/missing --run tar
-AUTOCONF = ${SHELL} /home/dormando/p/danga/memcached_github_new/missing --run autoconf
-AUTOHEADER = ${SHELL} /home/dormando/p/danga/memcached_github_new/missing --run autoheader
-AUTOMAKE = ${SHELL} /home/dormando/p/danga/memcached_github_new/missing --run automake-1.10
-AWK = gawk
+ACLOCAL = ${SHELL} /home/mdounin/work/memcached-repcached/memcached/missing --run aclocal-1.10
+AMTAR = ${SHELL} /home/mdounin/work/memcached-repcached/memcached/missing --run tar
+AUTOCONF = ${SHELL} /home/mdounin/work/memcached-repcached/memcached/missing --run autoconf
+AUTOHEADER = ${SHELL} /home/mdounin/work/memcached-repcached/memcached/missing --run autoheader
+AUTOMAKE = ${SHELL} /home/mdounin/work/memcached-repcached/memcached/missing --run automake-1.10
+AWK = nawk
 CC = gcc -std=gnu99
 CCDEPMODE = depmode=gcc3
 CFLAGS = -g -O2 -pthread -Wall -Werror -pedantic -Wmissing-prototypes -Wmissing-declarations -Wredundant-decls
 CPP = gcc -E
-CPPFLAGS = 
+CPPFLAGS = -I/usr/local/include 
 CYGPATH_W = echo
 DEFS = -DHAVE_CONFIG_H
 DEPDIR = .deps
@@ -69,42 +69,42 @@
 ECHO_C = 
 ECHO_N = -n
 ECHO_T = 
-EGREP = /bin/grep -E
+EGREP = /usr/bin/grep -E
 ENABLE_SASL = 
 EXEEXT = 
-GREP = /bin/grep
+GREP = /usr/bin/grep
 INSTALL = /usr/bin/install -c
 INSTALL_DATA = ${INSTALL} -m 644
 INSTALL_PROGRAM = ${INSTALL}
 INSTALL_SCRIPT = ${INSTALL}
 INSTALL_STRIP_PROGRAM = $(install_sh) -c -s
-LDFLAGS = 
+LDFLAGS = -L/usr/local/lib 
 LIBOBJS = 
 LIBS =  -levent
 LTLIBOBJS = 
-MAKEINFO = ${SHELL} /home/dormando/p/danga/memcached_github_new/missing --run makeinfo
-MKDIR_P = /usr/bin/mkdir -p
+MAKEINFO = ${SHELL} /home/mdounin/work/memcached-repcached/memcached/missing --run makeinfo
+MKDIR_P = .././install-sh -c -d
 OBJEXT = o
 PACKAGE = memcached
 PACKAGE_BUGREPORT = brad@danga.com
 PACKAGE_NAME = memcached
-PACKAGE_STRING = memcached 1.4.4
+PACKAGE_STRING = memcached 1.4.4_49_g6b6b7ed
 PACKAGE_TARNAME = memcached
-PACKAGE_VERSION = 1.4.4
+PACKAGE_VERSION = 1.4.4_49_g6b6b7ed
 PATH_SEPARATOR = :
 PROFILER = /usr/bin/gcov
 PROFILER_FLAGS = -fprofile-arcs -ftest-coverage
 PROFILER_LDFLAGS = -lgcov
 SET_MAKE = 
-SHELL = /bin/sh
+SHELL = /usr/local/bin/bash
 STRIP = 
-VERSION = 1.4.4
+VERSION = 1.4.4_49_g6b6b7ed
 XML2RFC = no
-XSLTPROC = /usr/bin/xsltproc
-abs_builddir = /home/dormando/p/danga/memcached_github_new/doc
-abs_srcdir = /home/dormando/p/danga/memcached_github_new/doc
-abs_top_builddir = /home/dormando/p/danga/memcached_github_new
-abs_top_srcdir = /home/dormando/p/danga/memcached_github_new
+XSLTPROC = /usr/local/bin/xsltproc
+abs_builddir = /home/mdounin/work/memcached-repcached/memcached/doc
+abs_srcdir = /home/mdounin/work/memcached-repcached/memcached/doc
+abs_top_builddir = /home/mdounin/work/memcached-repcached/memcached
+abs_top_srcdir = /home/mdounin/work/memcached-repcached/memcached
 ac_ct_CC = gcc
 am__include = include
 am__leading_dot = .
@@ -112,10 +112,10 @@
 am__tar = ${AMTAR} chof - "$$tardir"
 am__untar = ${AMTAR} xf -
 bindir = ${exec_prefix}/bin
-build = x86_64-unknown-linux-gnu
+build = i386-unknown-freebsd6.2
 build_alias = 
-build_cpu = x86_64
-build_os = linux-gnu
+build_cpu = i386
+build_os = freebsd6.2
 build_vendor = unknown
 builddir = .
 datadir = ${datarootdir}
@@ -123,21 +123,21 @@
 docdir = ${datarootdir}/doc/${PACKAGE_TARNAME}
 dvidir = ${docdir}
 exec_prefix = ${prefix}
-host = x86_64-unknown-linux-gnu
+host = i386-unknown-freebsd6.2
 host_alias = 
-host_cpu = x86_64
-host_os = linux-gnu
+host_cpu = i386
+host_os = freebsd6.2
 host_vendor = unknown
 htmldir = ${docdir}
 includedir = ${prefix}/include
 infodir = ${datarootdir}/info
-install_sh = $(SHELL) /home/dormando/p/danga/memcached_github_new/install-sh
+install_sh = $(SHELL) /home/mdounin/work/memcached-repcached/memcached/install-sh
 libdir = ${exec_prefix}/lib
 libexecdir = ${exec_prefix}/libexec
 localedir = ${datarootdir}/locale
 localstatedir = ${prefix}/var
 mandir = ${datarootdir}/man
-mkdir_p = /usr/bin/mkdir -p
+mkdir_p = $(top_builddir)/./install-sh -c -d
 oldincludedir = /usr/include
 pdfdir = ${docdir}
 prefix = /usr/local
@@ -147,10 +147,10 @@
 sharedstatedir = ${prefix}/com
 srcdir = .
 sysconfdir = ${prefix}/etc
-target = x86_64-unknown-linux-gnu
+target = i386-unknown-freebsd6.2
 target_alias = 
-target_cpu = x86_64
-target_os = linux-gnu
+target_cpu = i386
+target_os = freebsd6.2
 target_vendor = unknown
 top_build_prefix = ../
 top_builddir = ..
@@ -379,10 +379,10 @@
 	no $< $@
 
 %.chk: %.xml xml2rfc/rfc2629-refchk.xsl
-	/usr/bin/xsltproc xml2rfc/rfc2629-refchk.xsl $< >$@
+	/usr/local/bin/xsltproc xml2rfc/rfc2629-refchk.xsl $< >$@
 
 %.full: %.xml xml2rfc/rfc2629-noinc.xsl
-	/usr/bin/xsltproc xml2rfc/rfc2629-noinc.xsl $< >$@
+	/usr/local/bin/xsltproc xml2rfc/rfc2629-noinc.xsl $< >$@
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
 .NOEXPORT:
diff -urN --exclude *.m4 memcached-1.4.4/items.c repcached-2.2-1.4.4/items.c
--- memcached-1.4.4/items.c	Sat Oct 24 00:38:01 2009
+++ repcached-2.2-1.4.4/items.c	Tue Feb  9 23:02:45 2010
@@ -155,6 +155,9 @@
                     STATS_LOCK();
                     stats.evictions++;
                     STATS_UNLOCK();
+#ifdef USE_REPLICATION
+                    replication_call_del(ITEM_key(search), search->nkey);
+#endif /* USE_REPLICATION */
                 }
                 do_item_unlink(search);
                 break;
@@ -288,8 +291,14 @@
     stats.total_items += 1;
     STATS_UNLOCK();
 
+#ifdef USE_REPLICATION
+    /* Allocate a new CAS ID on link. */
+    if(!(it->it_flags & ITEM_REPDATA))
+        ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);
+#else
     /* Allocate a new CAS ID on link. */
     ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);
+#endif /* USE_REPLICATION */
 
     item_link_q(it);
 
diff -urN --exclude *.m4 memcached-1.4.4/memcached.c repcached-2.2-1.4.4/memcached.c
--- memcached-1.4.4/memcached.c	Fri Nov 27 08:45:13 2009
+++ repcached-2.2-1.4.4/memcached.c	Wed Feb 10 16:08:37 2010
@@ -102,6 +102,30 @@
 
 static void conn_free(conn *c);
 
+#ifdef USE_REPLICATION
+static int   rep_exit = 0;
+static conn *rep_recv = NULL;
+static conn *rep_send = NULL;
+static conn *rep_conn = NULL;
+static conn *rep_serv = NULL;
+static int  server_socket_replication(const int);
+static void server_close_replication(void);
+static int  replication_init(void);
+static int  replication_server_init(void);
+static int  replication_client_init(void);
+static int  replication_start(void);
+static int  replication_connect(void);
+static int  replication_close(void);
+static void replication_dispatch_close(void);
+static int  replication_marugoto(int);
+static int  replication_send(conn *);
+static int  replication_pop(void);
+static int  replication_push(void);
+static int  replication_exit(void);
+static int  replication_item(Q_ITEM *);
+static pthread_mutex_t replication_pipe_lock = PTHREAD_MUTEX_INITIALIZER;
+#endif /* USE_REPLICATION */
+
 /** exported globals **/
 struct stats stats;
 struct settings settings;
@@ -194,6 +218,11 @@
     settings.backlog = 1024;
     settings.binding_protocol = negotiating_prot;
     settings.item_size_max = 1024 * 1024; /* The famous 1MB upper limit. */
+#ifdef USE_REPLICATION
+    settings.rep_addr.s_addr = htonl(INADDR_ANY);
+    settings.rep_port = 11212;
+    settings.rep_qmax = 8192;
+#endif /* USE_REPLICATION */
 }
 
 /*
@@ -382,6 +411,10 @@
                 prot_text(c->protocol));
         } else if (IS_UDP(transport)) {
             fprintf(stderr, "<%d server listening (udp)\n", sfd);
+#ifdef USE_REPLICATION
+        } else if (init_state == conn_rep_listen) {
+            fprintf(stderr, "<%d server listening (replication)\n", sfd);
+#endif /* USE_REPLICATION */
         } else if (c->protocol == negotiating_prot) {
             fprintf(stderr, "<%d new auto-negotiating client connection\n",
                     sfd);
@@ -593,7 +626,11 @@
                                        "conn_nread",
                                        "conn_swallow",
                                        "conn_closing",
-                                       "conn_mwrite" };
+                                       "conn_mwrite",
+                                       "conn_repconnect",
+                                       "conn_rep_listen",
+                                       "conn_pipe_recv",
+                                       "conn_pipe_send" };
     return statenames[state];
 }
 
@@ -752,6 +789,14 @@
 
     assert(c != NULL);
 
+#ifdef USE_REPLICATION
+    if (c == rep_conn){
+        if (settings.verbose > 1)
+            fprintf(stderr, "REP>%d %s\n", c->sfd, str);
+        conn_set_state(c, conn_new_cmd);
+        return;
+    }
+#endif /* USE_REPLICATION */
     if (c->noreply) {
         if (settings.verbose > 1)
             fprintf(stderr, ">%d NOREPLY %s\n", c->sfd, str);
@@ -791,9 +836,11 @@
     int comm = c->cmd;
     enum store_item_type ret;
 
-    pthread_mutex_lock(&c->thread->stats.mutex);
-    c->thread->stats.slab_stats[it->slabs_clsid].set_cmds++;
-    pthread_mutex_unlock(&c->thread->stats.mutex);
+    if (c->thread) {
+        pthread_mutex_lock(&c->thread->stats.mutex);
+        c->thread->stats.slab_stats[it->slabs_clsid].set_cmds++;
+        pthread_mutex_unlock(&c->thread->stats.mutex);
+    }
 
     if (strncmp(ITEM_data(it) + it->nbytes - 2, "\r\n", 2) != 0) {
         out_string(c, "CLIENT_ERROR bad data chunk");
@@ -832,6 +879,11 @@
 
       switch (ret) {
       case STORED:
+#ifdef USE_REPLICATION
+          if( c != rep_conn ){
+            replication_call_rep(ITEM_key(it), it->nkey);
+          }
+#endif /* USE_REPLICATION */
           out_string(c, "STORED");
           break;
       case EXISTS:
@@ -2410,6 +2462,11 @@
     APPEND_STAT("listen_disabled_num", "%llu", (unsigned long long)stats.listen_disabled_num);
     APPEND_STAT("threads", "%d", settings.num_threads);
     APPEND_STAT("conn_yields", "%llu", (unsigned long long)thread_stats.conn_yields);
+#ifdef USE_REPLICATION
+    APPEND_STAT("replication", "MASTER", 0);
+    APPEND_STAT("repcached_version", "%s", REPCACHED_VERSION);
+    APPEND_STAT("repcached_qi_free", "%u", settings.rep_qmax - get_qi_count());
+#endif /*USE_REPLICATION*/
     STATS_UNLOCK();
 }
 
@@ -2797,6 +2854,11 @@
     switch(add_delta(c, it, incr, delta, temp)) {
     case OK:
         out_string(c, temp);
+#ifdef USE_REPLICATION
+        if( c != rep_conn){
+            replication_call_rep(ITEM_key(it), it->nkey);
+        }
+#endif /* USE_REPLICATION */
         break;
     case NON_NUMERIC:
         out_string(c, "CLIENT_ERROR cannot increment or decrement non-numeric value");
@@ -2911,17 +2973,25 @@
     if (it) {
         MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);
 
-        pthread_mutex_lock(&c->thread->stats.mutex);
-        c->thread->stats.slab_stats[it->slabs_clsid].delete_hits++;
-        pthread_mutex_unlock(&c->thread->stats.mutex);
+        if (c->thread) {
+            pthread_mutex_lock(&c->thread->stats.mutex);
+            c->thread->stats.slab_stats[it->slabs_clsid].delete_hits++;
+            pthread_mutex_unlock(&c->thread->stats.mutex);
+        }
 
         item_unlink(it);
         item_remove(it);      /* release our reference */
+#ifdef USE_REPLICATION
+        if( c != rep_conn )
+            replication_call_del(key, nkey);
+#endif /* USE_REPLICATION */
         out_string(c, "DELETED");
     } else {
-        pthread_mutex_lock(&c->thread->stats.mutex);
-        c->thread->stats.delete_misses++;
-        pthread_mutex_unlock(&c->thread->stats.mutex);
+        if (c->thread) {
+            pthread_mutex_lock(&c->thread->stats.mutex);
+            c->thread->stats.delete_misses++;
+            pthread_mutex_unlock(&c->thread->stats.mutex);
+        }
 
         out_string(c, "NOT_FOUND");
     }
@@ -2986,6 +3056,22 @@
 
         process_update_command(c, tokens, ntokens, comm, true);
 
+#ifdef USE_REPLICATION
+    } else if ((ntokens == 7) && (strcmp(tokens[COMMAND_TOKEN].value, "rep") == 0 && (comm = NREAD_SET)) && (c == rep_conn)) {
+
+        process_update_command(c, tokens, ntokens, comm, true);
+        if(c->item)
+            ((item *)(c->item))->it_flags |= ITEM_REPDATA;
+
+    } else if ((ntokens == 2) && (strcmp(tokens[COMMAND_TOKEN].value, "marugoto_end") == 0) && (c == rep_conn)) {
+        if(replication_start() == -1)
+            exit(EXIT_FAILURE);
+        if (settings.verbose > 0)
+            fprintf(stderr,"replication: start\n");
+        out_string(c, "OK");
+        return;
+
+#endif /* USE_REPLICATION */
     } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "incr") == 0)) {
 
         process_arithmetic_command(c, tokens, ntokens, 1);
@@ -3012,11 +3098,17 @@
 
         set_noreply_maybe(c, tokens, ntokens);
 
-        pthread_mutex_lock(&c->thread->stats.mutex);
-        c->thread->stats.flush_cmds++;
-        pthread_mutex_unlock(&c->thread->stats.mutex);
+        if (c->thread) {
+            pthread_mutex_lock(&c->thread->stats.mutex);
+            c->thread->stats.flush_cmds++;
+            pthread_mutex_unlock(&c->thread->stats.mutex);
+        }
 
         if(ntokens == (c->noreply ? 3 : 2)) {
+#ifdef USE_REPLICATION
+            if( c != rep_conn )
+                replication_call_flush_all();
+#endif
             settings.oldest_live = current_time - 1;
             item_flush_expired();
             out_string(c, "OK");
@@ -3029,6 +3121,11 @@
             return;
         }
 
+#ifdef USE_REPLICATION
+        if( c != rep_conn )
+            replication_call_defer_flush_all(realtime(exptime) + process_started);
+#endif
+        settings.oldest_live = realtime(exptime) - 1;
         /*
           If exptime is zero realtime() would return zero too, and
           realtime(exptime) - 1 would overflow to the max unsigned
@@ -3275,9 +3372,11 @@
         int avail = c->rsize - c->rbytes;
         res = read(c->sfd, c->rbuf + c->rbytes, avail);
         if (res > 0) {
-            pthread_mutex_lock(&c->thread->stats.mutex);
-            c->thread->stats.bytes_read += res;
-            pthread_mutex_unlock(&c->thread->stats.mutex);
+            if (c->thread) {
+                pthread_mutex_lock(&c->thread->stats.mutex);
+                c->thread->stats.bytes_read += res;
+                pthread_mutex_unlock(&c->thread->stats.mutex);
+            }
             gotdata = READ_DATA_RECEIVED;
             c->rbytes += res;
             if (res == avail) {
@@ -3423,6 +3522,12 @@
 
     assert(c != NULL);
 
+#ifdef USE_REPLICATION
+    if(rep_exit && (c->state != conn_pipe_recv)){
+        return;
+    }
+#endif /* USE_REPLICATION */
+
     while (!stop) {
 
         switch(c->state) {
@@ -3502,9 +3607,11 @@
             if (nreqs >= 0) {
                 reset_cmd_handler(c);
             } else {
-                pthread_mutex_lock(&c->thread->stats.mutex);
-                c->thread->stats.conn_yields++;
-                pthread_mutex_unlock(&c->thread->stats.mutex);
+                if (c->thread) {
+                    pthread_mutex_lock(&c->thread->stats.mutex);
+                    c->thread->stats.conn_yields++;
+                    pthread_mutex_unlock(&c->thread->stats.mutex);
+                }
                 if (c->rbytes > 0) {
                     /* We have already read in data into the input buffer,
                        so libevent will most likely not signal read events
@@ -3545,9 +3652,11 @@
             /*  now try reading from the socket */
             res = read(c->sfd, c->ritem, c->rlbytes);
             if (res > 0) {
-                pthread_mutex_lock(&c->thread->stats.mutex);
-                c->thread->stats.bytes_read += res;
-                pthread_mutex_unlock(&c->thread->stats.mutex);
+                if (c->thread) {
+                    pthread_mutex_lock(&c->thread->stats.mutex);
+                    c->thread->stats.bytes_read += res;
+                    pthread_mutex_unlock(&c->thread->stats.mutex);
+                }
                 if (c->rcurr == c->ritem) {
                     c->rcurr += res;
                 }
@@ -3600,9 +3709,11 @@
             /*  now try reading from the socket */
             res = read(c->sfd, c->rbuf, c->rsize > c->sbytes ? c->sbytes : c->rsize);
             if (res > 0) {
-                pthread_mutex_lock(&c->thread->stats.mutex);
-                c->thread->stats.bytes_read += res;
-                pthread_mutex_unlock(&c->thread->stats.mutex);
+                if (c->thread) {
+                    pthread_mutex_lock(&c->thread->stats.mutex);
+                    c->thread->stats.bytes_read += res;
+                    pthread_mutex_unlock(&c->thread->stats.mutex);
+                }
                 c->sbytes -= res;
                 break;
             }
@@ -3698,6 +3809,10 @@
         case conn_closing:
             if (IS_UDP(c->transport))
                 conn_cleanup(c);
+#ifdef USE_REPLICATION
+            else if(c == rep_conn)
+                replication_close();
+#endif /*USE_REPLICATION*/
             else
                 conn_close(c);
             stop = true;
@@ -3706,6 +3821,70 @@
         case conn_max_state:
             assert(false);
             break;
+
+#ifdef USE_REPLICATION
+        case conn_pipe_recv:
+            if(replication_pop()){
+                replication_close();
+            }else{
+                replication_send(rep_conn);
+            }
+            stop = true;
+            break;
+
+        case conn_rep_listen:
+            if (settings.verbose > 0)
+                fprintf(stderr,"replication: accept\n");
+            addrlen = sizeof(addr);
+            res = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
+            if(res == -1){
+                if(errno == EAGAIN || errno == EWOULDBLOCK) {
+                } else if (errno == EMFILE) {
+                    fprintf(stderr, "replication: Too many opened connections\n");
+                } else {
+                    fprintf(stderr, "replication: accept error\n");
+                }
+            }else{
+                if(rep_conn){
+                    close(res);
+                    fprintf(stderr,"replication: already connected\n");
+                }else{
+                    if((flags = fcntl(res, F_GETFL, 0)) < 0 || fcntl(res, F_SETFL, flags | O_NONBLOCK) < 0){
+                        close(res);
+                        fprintf(stderr, "replication: Can't Setting O_NONBLOCK\n");
+                    }else{
+                        server_close_replication();
+                        rep_conn = conn_new(res, conn_read, EV_READ | EV_PERSIST, DATA_BUFFER_SIZE, tcp_transport, main_base);
+                        rep_conn->item   = NULL;
+                        rep_conn->rbytes = 0;
+                        rep_conn->rcurr  = rep_conn->rbuf;
+                        replication_connect();
+                        replication_marugoto(1);
+                        replication_marugoto(0);
+                    }
+                }
+            }
+            stop = true;
+            break;
+
+        case conn_repconnect:
+            rep_conn = c;
+            replication_connect();
+            conn_set_state(c, conn_read);
+            if (settings.verbose > 0)
+                fprintf(stderr,"replication: marugoto copying\n");
+            if(!update_event(c, EV_READ | EV_PERSIST)){
+                fprintf(stderr, "replication: Couldn't update event\n");
+                conn_set_state(c, conn_closing);
+            }
+            stop = true;
+            break;
+
+        case conn_pipe_send:
+            /* should not happen */
+            fprintf(stderr, "replication: unexpected conn_pipe_send state\n");
+            break;
+#endif /* USE_REPLICATION */
         }
     }
 
@@ -4002,6 +4181,89 @@
     return 0;
 }
 
+#ifdef USE_REPLICATION
+static int server_socket_replication(const int port) {
+    int sfd;
+    struct linger ling = {0, 0};
+    struct addrinfo *ai;
+    struct addrinfo *next;
+    struct addrinfo hints;
+    char port_buf[NI_MAXSERV];
+    int error;
+    int success = 0;
+
+    int flags =1;
+
+    memset(&hints, 0, sizeof (hints));
+    hints.ai_flags = AI_PASSIVE|AI_ADDRCONFIG;
+    hints.ai_family = AF_UNSPEC;
+    hints.ai_protocol = IPPROTO_TCP;
+    hints.ai_socktype = SOCK_STREAM;
+    snprintf(port_buf, NI_MAXSERV, "%d", port);
+    error= getaddrinfo(settings.inter, port_buf, &hints, &ai);
+    if (error != 0) {
+      if (error != EAI_SYSTEM)
+        fprintf(stderr, "getaddrinfo(): %s\n", gai_strerror(error));
+      else
+        perror("getaddrinfo()");
+
+      return 1;
+    }
+
+    for (next= ai; next; next= next->ai_next) {
+        conn *rep_serv_add;
+        if ((sfd = new_socket(next)) == -1) {
+            freeaddrinfo(ai);
+            return 1;
+        }
+        setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));
+        setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));
+        setsockopt(sfd, SOL_SOCKET, SO_LINGER,    (void *)&ling,  sizeof(ling));
+        setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (void *)&flags, sizeof(flags));
+
+        if (bind(sfd, next->ai_addr, next->ai_addrlen) == -1) {
+            if (errno != EADDRINUSE) {
+                perror("bind()");
+                close(sfd);
+                freeaddrinfo(ai);
+                return 1;
+            }
+            close(sfd);
+            continue;
+        } else {
+            success++;
+            if (listen(sfd, 1024) == -1) {
+                perror("listen()");
+                close(sfd);
+                freeaddrinfo(ai);
+                return 1;
+            }
+        }
+
+        if (!(rep_serv_add = conn_new(sfd, conn_rep_listen,
+                                       EV_READ | EV_PERSIST, 1, tcp_transport, main_base))) {
+            fprintf(stderr, "failed to create replication server connection\n");
+            exit(EXIT_FAILURE);
+        }
+
+        rep_serv_add->next = rep_serv;
+        rep_serv = rep_serv_add;
+    }
+
+    freeaddrinfo(ai);
+
+    /* Return zero iff we detected no errors in starting up connections */
+    return success == 0;
+}
+
+static void server_close_replication(void) {
+  while(rep_serv){
+      conn_close(rep_serv);
+      rep_serv = rep_serv->next;
+  }
+}
+#endif /* USE_REPLICATION */
+
 /*
  * We keep the current time of day in a global variable that's updated by a
  * timer event. This saves us a bunch of time() system calls (we really only
@@ -4041,6 +4303,9 @@
 
 static void usage(void) {
     printf(PACKAGE " " VERSION "\n");
+#ifdef USE_REPLICATION
+    printf("repcached %s\n",REPCACHED_VERSION);
+#endif /* USE_REPLICATION */
     printf("-p <num>      TCP port number to listen on (default: 11211)\n"
            "-U <num>      UDP port number to listen on (default: 11211, 0 is off)\n"
            "-s <file>     UNIX socket path to listen on (disables network support)\n"
@@ -4088,6 +4353,10 @@
 #ifdef ENABLE_SASL
     printf("-S            Turn on Sasl authentication\n");
 #endif
+#ifdef USE_REPLICATION
+    printf("-x <ip_addr>  hostname or IP address of peer repcached\n");
+    printf("-X <num>      TCP port number for replication (default: 11212)\n");
+#endif /* USE_REPLICATION */
     return;
 }
 
@@ -4194,6 +4463,26 @@
     exit(EXIT_SUCCESS);
 }
 
+#ifdef USE_REPLICATION
+static void sig_handler_cb(int fd, short event, void *arg)
+{
+    struct event *signal = arg;
+
+    if (settings.verbose)
+        fprintf(stderr, "got signal %d\n", EVENT_SIGNAL(signal));
+
+    if (replication_exit()) {
+        exit(EXIT_FAILURE);
+    }
+
+    pthread_mutex_lock(&replication_pipe_lock);
+    if (!rep_send) {
+        exit(EXIT_SUCCESS);
+    }
+    pthread_mutex_unlock(&replication_pipe_lock);
+}
+#endif /* USE_REPLICATION */
+
 #ifndef HAVE_SIGIGNORE
 static int sigignore(int sig) {
     struct sigaction sa = { .sa_handler = SIG_IGN, .sa_flags = 0 };
@@ -4249,6 +4538,57 @@
 #endif
 }
 
+static void create_listening_sockets(void)
+{
+    /* create unix mode sockets after dropping privileges */
+    if (settings.socketpath != NULL) {
+        errno = 0;
+        if (server_socket_unix(settings.socketpath,settings.access)) {
+            vperror("failed to listen on UNIX socket: %s", settings.socketpath);
+            exit(EX_OSERR);
+        }
+    }
+
+    /* create the listening socket, bind it, and init */
+    if (settings.socketpath == NULL) {
+        const char *portnumber_filename = getenv("MEMCACHED_PORT_FILENAME");
+        char temp_portnumber_filename[PATH_MAX];
+        FILE *portnumber_file = NULL;
+
+        if (portnumber_filename != NULL) {
+            snprintf(temp_portnumber_filename,
+                     sizeof(temp_portnumber_filename),
+                     "%s.lck", portnumber_filename);
+
+            portnumber_file = fopen(temp_portnumber_filename, "a");
+            if (portnumber_file == NULL) {
+                fprintf(stderr, "Failed to open \"%s\": %s\n",
+                        temp_portnumber_filename, strerror(errno));
+            }
+        }
+
+        errno = 0;
+        if (settings.port && server_socket(settings.port, tcp_transport,
+                                           portnumber_file)) {
+            vperror("failed to listen on TCP port %d", settings.port);
+            exit(EX_OSERR);
+        }
+
+        /* create the UDP listening socket and bind it */
+        errno = 0;
+        if (settings.udpport && server_socket(settings.udpport, udp_transport,
+                                              portnumber_file)) {
+            vperror("failed to listen on UDP port %d", settings.udpport);
+            exit(EX_OSERR);
+        }
+
+        if (portnumber_file) {
+            fclose(portnumber_file);
+            rename(temp_portnumber_filename, portnumber_filename);
+        }
+    }
+}
+
 int main (int argc, char **argv) {
     int c;
     bool lock_memory = false;
@@ -4261,6 +4601,11 @@
     struct rlimit rlim;
     char unit = '\0';
     int size_max = 0;
+#ifdef USE_REPLICATION
+    struct in_addr   addr;
+    struct addrinfo  master_hint;
+    struct addrinfo *master_addr;
+#endif /* USE_REPLICATION */
     /* listening sockets */
     static int *l_socket = NULL;
 
@@ -4307,6 +4652,11 @@
           "B:"  /* Binding protocol */
           "I:"  /* Max item size */
           "S"   /* Sasl ON */
+#ifdef USE_REPLICATION
+          "X:"  /* replication port */
+          "x:"  /* replication master */
+          "q:"  /* replication queue length */
+#endif /* USE_REPLICATION */
         ))) {
         switch (c) {
         case 'a':
@@ -4462,6 +4812,31 @@
                 );
             }
             break;
+#ifdef USE_REPLICATION
+        case 'x':
+            if (inet_pton(AF_INET, optarg, &addr) <= 0) {
+                memset(&master_hint, 0, sizeof(master_hint));
+                master_hint.ai_flags    = 0;
+                master_hint.ai_socktype = 0;
+                master_hint.ai_protocol = 0;
+                if(!getaddrinfo(optarg, NULL, &master_hint, &master_addr)){
+                    settings.rep_addr = ((struct sockaddr_in *)(master_addr->ai_addr)) -> sin_addr;
+                    freeaddrinfo(master_addr);
+                }else{
+                    fprintf(stderr, "Illegal address: %s\n", optarg);
+                    return 1;
+                }
+            } else {
+                settings.rep_addr = addr;
+            }
+            break;
+        case 'X':
+            settings.rep_port = atoi(optarg);
+            break;
+        case 'q':
+            settings.rep_qmax = atoi(optarg);
+            break;
+#endif /* USE_REPLICATION */
         case 'S': /* set Sasl authentication to true. Default is false */
 #ifndef ENABLE_SASL
             fprintf(stderr, "This server is not built with SASL support.\n");
@@ -4587,6 +4962,17 @@
     /* initialize main thread libevent instance */
     main_base = event_init();
 
+#ifdef USE_REPLICATION
+    /* register events for SIGINT and SIGTERM to handle them in main thread */
+    struct event signal_int, signal_term;
+    event_set(&signal_int, SIGINT, EV_SIGNAL|EV_PERSIST, sig_handler_cb,
+              &signal_int);
+    event_add(&signal_int, NULL);
+    event_set(&signal_term, SIGTERM, EV_SIGNAL|EV_PERSIST, sig_handler_cb,
+              &signal_term);
+    event_add(&signal_term, NULL);
+#endif
+
     /* initialize other stuff */
     stats_init();
     assoc_init();
@@ -4615,63 +5001,21 @@
     /* initialise clock event */
     clock_handler(0, 0, 0);
 
-    /* create unix mode sockets after dropping privileges */
-    if (settings.socketpath != NULL) {
-        errno = 0;
-        if (server_socket_unix(settings.socketpath,settings.access)) {
-            vperror("failed to listen on UNIX socket: %s", settings.socketpath);
-            exit(EX_OSERR);
-        }
-    }
-
-    /* create the listening socket, bind it, and init */
-    if (settings.socketpath == NULL) {
-        int udp_port;
-
-        const char *portnumber_filename = getenv("MEMCACHED_PORT_FILENAME");
-        char temp_portnumber_filename[PATH_MAX];
-        FILE *portnumber_file = NULL;
-
-        if (portnumber_filename != NULL) {
-            snprintf(temp_portnumber_filename,
-                     sizeof(temp_portnumber_filename),
-                     "%s.lck", portnumber_filename);
-
-            portnumber_file = fopen(temp_portnumber_filename, "a");
-            if (portnumber_file == NULL) {
-                fprintf(stderr, "Failed to open \"%s\": %s\n",
-                        temp_portnumber_filename, strerror(errno));
-            }
-        }
-
-        errno = 0;
-        if (settings.port && server_socket(settings.port, tcp_transport,
-                                           portnumber_file)) {
-            vperror("failed to listen on TCP port %d", settings.port);
-            exit(EX_OSERR);
-        }
-
-        /*
-         * initialization order: first create the listening sockets
-         * (may need root on low ports), then drop root if needed,
-         * then daemonise if needed, then init libevent (in some cases
-         * descriptors created by libevent wouldn't survive forking).
-         */
-        udp_port = settings.udpport ? settings.udpport : settings.port;
-
-        /* create the UDP listening socket and bind it */
-        errno = 0;
-        if (settings.udpport && server_socket(settings.udpport, udp_transport,
-                                              portnumber_file)) {
-            vperror("failed to listen on UDP port %d", settings.udpport);
-            exit(EX_OSERR);
-        }
+    /*
+     * initialization order: first create the listening sockets
+     * (may need root on low ports), then drop root if needed,
+     * then daemonise if needed, then init libevent (in some cases
+     * descriptors created by libevent wouldn't survive forking).
+     */
 
-        if (portnumber_file) {
-            fclose(portnumber_file);
-            rename(temp_portnumber_filename, portnumber_filename);
-        }
+#ifdef USE_REPLICATION
+    if(replication_init() == -1){
+        fprintf(stderr, "faild to replication init\n");
+        exit(EXIT_FAILURE);
     }
+#else
+    create_listening_sockets();
+#endif
 
     /* Drop privileges no longer needed */
     drop_privileges();
@@ -4694,3 +5038,401 @@
 
     return EXIT_SUCCESS;
 }
+
+#ifdef USE_REPLICATION
+static int replication_start(void)
+{
+    static int start = 0;
+    if(start)
+        return(0);
+
+    create_listening_sockets();
+
+    start = 1;
+    return(0);
+}
+
+static int replication_server_init(void)
+{
+    rep_recv = NULL;
+    rep_send = NULL;
+    rep_conn = NULL;
+    if(server_socket_replication(settings.rep_port)){
+        fprintf(stderr, "replication: failed to initialize replication server socket\n");
+        return(-1);
+    }
+    if (settings.verbose > 0)
+        fprintf(stderr, "replication: listen\n");
+    return(replication_start());
+}
+
+static int replication_client_init(void)
+{
+    int s;
+    conn *c;
+    struct addrinfo    ai;
+    struct sockaddr_in server;
+
+    rep_recv  = NULL;
+    rep_send  = NULL;
+    rep_conn  = NULL;
+
+    memset(&ai,0,sizeof(ai));
+    ai.ai_family   = AF_INET;
+    ai.ai_socktype = SOCK_STREAM;
+    s = new_socket(&ai);
+
+    if(s == -1) {
+        fprintf(stderr, "replication: failed to replication client socket\n");
+        return(-1);
+    }else{
+        /* connect */
+        memset((char *)&server, 0, sizeof(server));
+        server.sin_family = AF_INET;
+        server.sin_addr   = settings.rep_addr;
+        server.sin_port   = htons(settings.rep_port);
+        if (settings.verbose > 0)
+            fprintf(stderr,"replication: connect (peer=%s:%d)\n", inet_ntoa(settings.rep_addr), settings.rep_port);
+        if(connect(s,(struct sockaddr *)&server, sizeof(server)) == 0){
+            c = conn_new(s, conn_repconnect, EV_WRITE | EV_PERSIST, DATA_BUFFER_SIZE, false, main_base);
+            if(c == NULL){
+                fprintf(stderr, "replication: failed to create client conn");
+                close(s);
+                return(-1);
+            }
+            drive_machine(c);
+        }else{
+            if(errno == EINPROGRESS){
+                c = conn_new(s, conn_repconnect, EV_WRITE | EV_PERSIST, DATA_BUFFER_SIZE, false, main_base);
+                if(c == NULL){
+                    fprintf(stderr, "replication: failed to create client conn");
+                    close(s);
+                    return(-1);
+                }
+            }else{
+                fprintf(stdout,"replication: can't connect %s:%d\n", inet_ntoa(server.sin_addr), ntohs(server.sin_port));
+                close(s);
+                return(-1);
+            }
+        }
+    }
+    return(0);
+}
+
+static int replication_init(void)
+{
+    if(settings.rep_addr.s_addr != htonl(INADDR_ANY)){
+        if(replication_client_init() != -1){
+            return(0);
+        }
+    }
+    return(replication_server_init());
+}
+
+static int replication_connect(void)
+{
+    int f;
+    int p[2];
+
+    if(pipe(p) == -1){
+        fprintf(stderr, "replication: can't create pipe\n");
+        return(-1);
+    }else{
+        if((f = fcntl(p[0], F_GETFL, 0)) < 0 || fcntl(p[0], F_SETFL, f | O_NONBLOCK) < 0) {
+            fprintf(stderr, "replication: can't setting O_NONBLOCK pipe[0]\n");
+            return(-1);
+        }
+        if((f = fcntl(p[1], F_GETFL, 0)) < 0 || fcntl(p[1], F_SETFL, f | O_NONBLOCK) < 0) {
+            fprintf(stderr, "replication: can't setting O_NONBLOCK pipe[0]\n");
+            return(-1);
+        }
+        pthread_mutex_lock(&replication_pipe_lock);
+        rep_recv = conn_new(p[0], conn_pipe_recv, EV_READ | EV_PERSIST, DATA_BUFFER_SIZE, tcp_transport, main_base);
+        rep_send = conn_new(p[1], conn_pipe_send, EV_READ | EV_PERSIST, DATA_BUFFER_SIZE, tcp_transport, main_base);
+        event_del(&rep_send->event);
+        pthread_mutex_unlock(&replication_pipe_lock);
+    }
+    return(0);
+}
+
+static int replication_close(void)
+{
+    int     c;
+    int     r;
+    Q_ITEM *q;
+
+    if(settings.verbose > 0)
+        fprintf(stderr,"replication: close\n");
+    if(rep_recv){
+        rep_recv->rbytes = sizeof(q);
+        rep_recv->rcurr  = rep_recv->rbuf;
+        c = 0;
+        do{
+            r = read(rep_recv->sfd, rep_recv->rcurr, rep_recv->rbytes);
+            if(r == -1){
+                break;
+            }
+            rep_recv->rbytes -= r;
+            rep_recv->rcurr  += r;
+            if(!rep_recv->rbytes){
+                memcpy(&q, rep_recv->rbuf, sizeof(q));
+                rep_recv->rbytes = sizeof(q);
+                rep_recv->rcurr  = rep_recv->rbuf;
+                qi_free(q);
+                c++;
+            }
+        }while(r);
+        conn_close(rep_recv);
+        rep_recv = NULL;
+        if (settings.verbose > 1) {
+            fprintf(stderr, "replication: qitem free %d items\n", qi_free_list());
+            fprintf(stderr, "replication: close recv %d items\n", c);
+        }
+    }
+    pthread_mutex_lock(&replication_pipe_lock);
+    if(rep_send){
+        conn_close(rep_send);
+        rep_send = NULL;
+        if (settings.verbose > 1)
+            fprintf(stderr,"replication: close send\n");
+    }
+    pthread_mutex_unlock(&replication_pipe_lock);
+    if(rep_conn){
+        conn_close(rep_conn);
+        rep_conn = NULL;
+        if (settings.verbose > 1)
+            fprintf(stderr,"replication: close conn\n");
+    }
+    if(!rep_exit)
+        replication_server_init();
+    return(0);
+}
+
+static void replication_dispatch_close(void)
+{
+    if (settings.verbose > 1)
+        fprintf(stderr, "replication: dispatch close\n");
+    pthread_mutex_lock(&replication_pipe_lock);
+    if (rep_send) {
+        conn_close(rep_send);
+        rep_send = NULL;
+    }
+    pthread_mutex_unlock(&replication_pipe_lock);
+}
+
+static int replication_marugoto(int f)
+{
+    static int   keysend  = 0;
+    static int   keycount = 0;
+    static char *keylist  = NULL;
+    static char *keyptr   = NULL;
+
+    if(f){
+        if(keylist){
+            free(keylist);
+            keylist  = NULL;
+            keyptr   = NULL;
+            keycount = 0;
+            keysend  = 0;
+        }
+        pthread_mutex_lock(&cache_lock);
+        keylist = (char *)assoc_key_snap((int *)&keycount);
+        pthread_mutex_unlock(&cache_lock);
+        keyptr  = keylist;
+        if (!keyptr){
+            replication_call_marugoto_end();
+        }else{
+        if (settings.verbose > 0)
+            fprintf(stderr,"replication: marugoto start\n");
+        }
+    }else{
+        if(keyptr){
+            while(*keyptr){
+                item *it = item_get(keyptr, strlen(keyptr));
+                if(it){
+                    item_remove(it);
+                    if(replication_call_rep(keyptr, strlen(keyptr)) == -1){
+                        return(-1);
+                    }else{
+                        keysend++;
+                        keyptr += strlen(keyptr) + 1;
+                        return(0);
+                    }
+                }
+                keyptr += strlen(keyptr) + 1;
+            }
+            if(settings.verbose > 0)
+                fprintf(stderr,"replication: marugoto %d\n", keysend);
+            replication_call_marugoto_end();
+            if(settings.verbose > 0)
+                fprintf(stderr,"replication: marugoto owari\n");
+            free(keylist);
+            keylist  = NULL;
+            keyptr   = NULL;
+            keycount = 0;
+            keysend  = 0;
+        }
+    }
+    return(0);
+}
+
+static int replication_send(conn *c)
+{
+    while(c->wbytes){
+        int w = write(c->sfd, c->wcurr, c->wbytes);
+        if(w == -1){
+            if(errno == EAGAIN || errno == EINTR){
+            }else{
+                fprintf(stderr,"replication: send error\n");
+                replication_close();
+                break;
+            }
+        }else{
+            c->wbytes -= w;
+            c->wcurr  += w;
+        }
+    }
+    return(c->wbytes);
+}
+
+static int replication_pop(void)
+{
+    int      r;
+    int      c;
+    int      m;
+    Q_ITEM **q;
+
+    if(settings.verbose > 1)
+        fprintf(stderr, "replication: pop\n");
+
+    if(!rep_recv)
+        return(0);
+
+    r = read(rep_recv->sfd, rep_recv->rbuf, rep_recv->rsize);
+    if(r == -1){
+        if(errno == EAGAIN || errno == EINTR){
+        }else{
+            fprintf(stderr,"replication: pop error %d\n", errno);
+            return(-1);
+        }
+    }if(r == 0){
+        /* other end closed, trigger replication_close() */
+        return(-1);
+    }else{
+        c = r / sizeof(Q_ITEM *);
+        m = r % sizeof(Q_ITEM *);
+        q = (Q_ITEM **)(rep_recv->rbuf);
+        while(c--){
+            if(q[c]){
+                if(rep_conn && replication_cmd(rep_conn, q[c])){
+                    replication_item(q[c]); /* error retry */
+                }else{
+                    qi_free(q[c]);
+                }
+            }else{
+                if(!rep_exit){
+                    if (settings.verbose)
+                        fprintf(stderr,"replication: cleanup start\n");
+                    rep_exit = 1;
+                }
+            }
+        }
+    }
+    if(rep_exit){
+        if(rep_conn->wbytes){
+            /* retry */
+            if(replication_exit()){
+                replication_close();
+                fprintf(stderr,"replication: cleanup error\n");
+                exit(EXIT_FAILURE);
+            }
+        }else{
+            /* finish */
+            replication_close();
+            if (settings.verbose)
+                fprintf(stderr,"replication: cleanup complete\n");
+            exit(EXIT_SUCCESS);
+        }
+    }
+    replication_marugoto(0);
+    return(0);
+}
+
+static int replication_push(void)
+{
+    int w;
+
+    while(rep_send->wbytes){
+        w = write(rep_send->sfd, rep_send->wcurr, rep_send->wbytes);
+        if(w == -1){
+            if(errno == EAGAIN || errno == EINTR){
+                fprintf(stderr,"replication: push EAGAIN or EINTR\n");
+            }else{
+                return(-1);
+            }
+        }else{
+            rep_send->wbytes -= w;
+            rep_send->wcurr  += w;
+        }
+    }
+    rep_send->wcurr = rep_send->wbuf;
+    return(0);
+}
+
+static int replication_exit(void)
+{
+    return(replication_item(NULL));
+}
+
+static int replication_item(Q_ITEM *q)
+{
+    pthread_mutex_lock(&replication_pipe_lock);
+    if (!rep_send) {
+        pthread_mutex_unlock(&replication_pipe_lock);
+        return 0;
+    }
+    if(rep_send->wcurr + rep_send->wbytes + sizeof(q) > rep_send->wbuf + rep_send->wsize){
+        fprintf(stderr,"replication: buffer over fllow\n");
+        if(q){
+            qi_free(q);
+        }
+        pthread_mutex_unlock(&replication_pipe_lock);
+        replication_dispatch_close();
+        return(-1);
+    }
+    memcpy(rep_send->wcurr + rep_send->wbytes, &q, sizeof(q));
+    rep_send->wbytes += sizeof(q);
+    if(replication_push()){
+        fprintf(stderr, "replication: push error\n");
+        if(q){
+            qi_free(q);
+        }
+        pthread_mutex_unlock(&replication_pipe_lock);
+        replication_dispatch_close();
+        return(-1);
+    }
+    pthread_mutex_unlock(&replication_pipe_lock);
+    return(0);
+}
+
+int replication(enum CMD_TYPE type, R_CMD *cmd)
+{
+    Q_ITEM *q;
+
+    pthread_mutex_lock(&replication_pipe_lock);
+    if (!rep_send) {
+        pthread_mutex_unlock(&replication_pipe_lock);
+        return 0;
+    }
+    pthread_mutex_unlock(&replication_pipe_lock);
+
+    if((q = qi_new(type, cmd, false))) {
+        replication_item(q);
+    }else{
+        fprintf(stderr,"replication: can't create Q_ITEM\n");
+        replication_dispatch_close();
+        return(-1);
+    }
+    return(0);
+}
+#endif /* USE_REPLICATION */
diff -urN --exclude *.m4 memcached-1.4.4/memcached.h repcached-2.2-1.4.4/memcached.h
--- memcached-1.4.4/memcached.h	Thu Nov 26 03:37:49 2009
+++ repcached-2.2-1.4.4/memcached.h	Tue Feb  9 23:02:45 2010
@@ -144,7 +144,13 @@
     conn_swallow,    /**< swallowing unnecessary bytes w/o storing */
     conn_closing,    /**< closing this connection */
     conn_mwrite,     /**< writing out many items sequentially */
-    conn_max_state   /**< Max state value (used for assertion) */
+#ifdef USE_REPLICATION
+    conn_repconnect, /**< replication connecting to master */
+    conn_rep_listen, /**< replication listening socket */
+    conn_pipe_recv,  /**< replication command pipe recv */
+    conn_pipe_send,  /**< replication command pipe send */
+#endif /* USE_REPLICATION */
+    conn_max_state,  /**< Max state value (used for assertion) */
 };
 
 enum bin_substates {
@@ -240,7 +246,9 @@
     uint64_t      get_hits;
     uint64_t      get_misses;
     uint64_t      evictions;
+#if 0
     time_t        started;          /* when the process was started */
+#endif
     bool          accepting_conns;  /* whether we are currently accepting */
     uint64_t      listen_disabled_num;
 };
@@ -274,6 +282,11 @@
     int backlog;
     int item_size_max;        /* Maximum item size, and upper end for slabs */
     bool sasl;              /* SASL on/off */
+#ifdef USE_REPLICATION
+    struct in_addr rep_addr;    /* replication addr */
+    int rep_port;               /* replication port */
+    int rep_qmax;               /* replication QITEM max */
+#endif /*USE_REPLICATION*/
 };
 
 extern struct stats stats;
@@ -286,6 +299,10 @@
 /* temp */
 #define ITEM_SLABBED 4
 
+#ifdef USE_REPLICATION
+#define ITEM_REPDATA 128
+#endif /*USE_REPLICATION*/
+
 /**
  * Structure for storing items within memcached.
  */
@@ -438,6 +455,10 @@
 #include "trace.h"
 #include "hash.h"
 #include "util.h"
+
+#ifdef USE_REPLICATION
+#include "replication.h"
+#endif /* USE_REPLICATION */
 
 /*
  * Functions such as the libevent-related calls that need to do cross-thread
diff -urN --exclude *.m4 memcached-1.4.4/memcached.spec repcached-2.2-1.4.4/memcached.spec
--- memcached-1.4.4/memcached.spec	Fri Nov 27 09:34:55 2009
+++ repcached-2.2-1.4.4/memcached.spec	Wed Feb 10 19:12:03 2010
@@ -1,12 +1,12 @@
 Name:           memcached
 Version:        1.4.4
-Release:        1%{?dist}
+Release:        1.49_g6b6b7ed%{?dist}
 Summary:        High Performance, Distributed Memory Object Cache
 
 Group:          System Environment/Daemons
 License:        BSD
 URL:            http://www.danga.com/memcached/
-Source0:        http://memcached.googlecode.com/files/%{name}-1.4.4.tar.gz
+Source0:        http://memcached.googlecode.com/files/%{name}-1.4.4_49_g6b6b7ed.tar.gz
 BuildRoot:      %{_tmppath}/%{name}-%{version}-%{release}-root-%(%{__id_u} -n)
 
 BuildRequires:  libevent-devel
@@ -23,7 +23,7 @@
 web applications by alleviating database load.
 
 %prep
-%setup -q -n %{name}-1.4.4
+%setup -q -n %{name}-1.4.4_49_g6b6b7ed
 
 
 %build
diff -urN --exclude *.m4 memcached-1.4.4/replication.c repcached-2.2-1.4.4/replication.c
--- memcached-1.4.4/replication.c	Thu Jan  1 03:00:00 1970
+++ repcached-2.2-1.4.4/replication.c	Wed Feb 10 18:40:48 2010
@@ -0,0 +1,355 @@
+/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
+/*
+ *
+ */
+#include "memcached.h"
+#include "replication.h"
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+
+static Q_ITEM *q_freelist  = NULL;
+static int     q_itemcount = 0;
+static pthread_mutex_t replication_queue_lock = PTHREAD_MUTEX_INITIALIZER;
+
+int get_qi_count(void)
+{
+    int c;
+    pthread_mutex_lock(&replication_queue_lock);
+    c = q_itemcount;
+    pthread_mutex_unlock(&replication_queue_lock);
+    return(c);
+}
+
+Q_ITEM *qi_new(enum CMD_TYPE type, R_CMD *cmd, bool reuse)
+{
+    Q_ITEM     *q      = NULL;
+    char       *key    = NULL;
+    uint32_t    keylen = 0;
+    rel_time_t  time   = 0;
+
+    pthread_mutex_lock(&replication_queue_lock);
+    if(q_freelist){
+        q = q_freelist;
+        q_freelist = q->next;
+    }
+
+    if(NULL == q){
+        if(reuse) {
+            pthread_mutex_unlock(&replication_queue_lock);
+            return(NULL);
+        }
+        if(q_itemcount >= settings.rep_qmax) {
+            pthread_mutex_unlock(&replication_queue_lock);
+            return(NULL);
+        }
+        q = malloc(sizeof(Q_ITEM));
+        if (NULL == q){
+            fprintf(stderr,"replication: qi_new out of memory\n");
+            pthread_mutex_unlock(&replication_queue_lock);
+            return(NULL);
+        }
+        q_itemcount++;
+        if (settings.verbose > 2)
+            fprintf(stderr,"replication: alloc c=%d\n", q_itemcount);
+    }
+
+    pthread_mutex_unlock(&replication_queue_lock);
+
+    switch (type) {
+    case REPLICATION_REP:
+    case REPLICATION_DEL:
+        key    = cmd->key;
+        keylen = cmd->keylen;
+        break;
+    case REPLICATION_FLUSH_ALL:
+        break;
+    case REPLICATION_DEFER_FLUSH_ALL:
+        time   = cmd->time;
+        break;
+    case REPLICATION_MARUGOTO_END:
+        break;
+    default:
+        fprintf(stderr,"replication: got unknown command: %d\n", type);
+        return(NULL);
+    }
+
+    q->key  = NULL;
+    q->type = type;
+    q->time = time;
+    q->next = NULL;
+    if (keylen) {
+        q->key = malloc(keylen + 1);
+        if(NULL == q->key){
+            qi_free(q);
+            q = NULL;
+        }else{
+            memcpy(q->key, key, keylen);
+            *(q->key + keylen) = 0;
+        }
+    }
+
+    return(q);
+}
+
+void qi_free(Q_ITEM *q)
+{
+    if(q){
+        if(q->key){
+            free(q->key);
+            q->key = NULL;
+        }
+        pthread_mutex_lock(&replication_queue_lock);
+        q->next = q_freelist;
+        q_freelist = q;
+        pthread_mutex_unlock(&replication_queue_lock);
+    }
+}
+
+int qi_free_list()
+{
+    int     c = 0;
+    Q_ITEM *q = NULL;
+
+    pthread_mutex_lock(&replication_queue_lock);
+    while((q = q_freelist)){
+        q_itemcount--;
+        c++;
+        q_freelist = q->next;
+        free(q);
+    }
+    pthread_mutex_unlock(&replication_queue_lock);
+    return(c);
+}
+
+static int replication_get_num(char *p, int n)
+{
+    int  l;
+    char b[64];
+    if(p)
+        l = sprintf(p, "%u", n);
+    else
+        l = sprintf(b, "%u", n);
+    return(l);
+}
+
+int replication_call_rep(char *key, size_t keylen)
+{
+    R_CMD r;
+    r.key    = key;
+    r.keylen = keylen;
+    return(replication(REPLICATION_REP, &r));
+}
+
+int replication_call_del(char *key, size_t keylen)
+{
+    R_CMD r;
+    r.key    = key;
+    r.keylen = keylen;
+    return(replication(REPLICATION_DEL, &r));
+}
+
+int replication_call_flush_all()
+{
+    R_CMD r;
+    r.key = NULL;
+    return(replication(REPLICATION_FLUSH_ALL, &r));
+}
+
+int replication_call_defer_flush_all(const rel_time_t time)
+{
+    R_CMD r;
+    r.key  = NULL;
+    r.time = time;
+    return(replication(REPLICATION_DEFER_FLUSH_ALL, &r));
+}
+
+int replication_call_marugoto_end()
+{
+    R_CMD r;
+    r.key = NULL;
+    return(replication(REPLICATION_MARUGOTO_END, &r));
+}
+
+static int replication_alloc(conn *c, int s)
+{
+    char *p;
+    s += c->wbytes;
+    if(c->wsize < s){
+        while(c->wsize < s)
+            c->wsize += 4096;
+        if((p = malloc(c->wsize))){
+            memcpy(p, c->wbuf, c->wbytes);
+            free(c->wbuf);
+            c->wbuf = p;
+        }else{
+            return(-1);
+        }
+    }
+    return(0);
+}
+
+static int replication_del(conn *c, char *k)
+{
+    int   l = 0;
+    char *s = "delete ";
+    char *n = "\r\n";
+    char *p = NULL;
+
+    l += strlen(s);
+    l += strlen(k);
+    l += strlen(n);
+    if(replication_alloc(c,l) == -1){
+        fprintf(stderr, "replication: del malloc error\n");
+        return(-1);
+    }
+    p = c->wbuf + c->wbytes;
+    memcpy(p, s, strlen(s));
+    p += strlen(s);
+    memcpy(p, k, strlen(k));
+    p += strlen(k);
+    memcpy(p, n, strlen(n));
+    p += strlen(n);
+    c->wbytes = p - c->wbuf;
+    c->wcurr  = c->wbuf;
+    return(0);
+}
+
+static int replication_rep(conn *c, item *it)
+{
+    int exp = 0;
+    int len = 0;
+    char *s = "rep ";
+    char *n = "\r\n";
+    char *p = NULL;
+    char flag[40];
+
+    if(it->exptime)
+        exp = it->exptime + process_started;
+    flag[0]=0;
+    if((p=ITEM_suffix(it))){
+        int i;
+        memcpy(flag, p, it->nsuffix - 2);
+        flag[it->nsuffix - 2] = 0;
+        for(i=0;i<strlen(flag);i++){
+            if(flag[i] > ' ')
+                break;
+        }
+        memmove(flag,&flag[i],strlen(flag)-i);
+        for(p=flag;*p>' ';p++);
+        *p=0;
+    }
+    len += strlen(s);
+    len += it->nkey;
+    len += 1;
+    len += strlen(flag);
+    len += 1;
+    len += replication_get_num(NULL, exp);
+    len += 1;
+    len += replication_get_num(NULL, it->nbytes - 2);
+    len += 1;
+    len += replication_get_num(NULL, ITEM_get_cas(it));
+    len += strlen(n);
+    len += it->nbytes;
+    len += strlen(n);
+    if(replication_alloc(c,len) == -1){
+        fprintf(stderr, "replication: rep malloc error\n");
+        return(-1);
+    }
+    p = c->wbuf + c->wbytes;
+    memcpy(p, s, strlen(s));
+    p += strlen(s);
+    memcpy(p, ITEM_key(it), it->nkey);
+    p += it->nkey;
+    *(p++) = ' ';
+    memcpy(p, flag, strlen(flag));
+    p += strlen(flag);
+    *(p++) = ' ';
+    p += replication_get_num(p, exp);
+    *(p++) = ' ';
+    p += replication_get_num(p, it->nbytes - 2);
+    *(p++) = ' ';
+    p += replication_get_num(p, ITEM_get_cas(it));
+    memcpy(p, n, strlen(n));
+    p += strlen(n);
+    memcpy(p, ITEM_data(it), it->nbytes);
+    p += it->nbytes;
+    c->wbytes = p - c->wbuf;
+    c->wcurr  = c->wbuf;
+    return(0);
+}
+
+static int replication_flush_all(conn *c, rel_time_t exp)
+{
+    char *s = "flush_all ";
+    char *n = "\r\n";
+    char *p = NULL;
+
+    int l = strlen(s) + strlen(n);
+    if (exp > 0)
+        l += replication_get_num(NULL, exp);
+    if(replication_alloc(c,l) == -1){
+        fprintf(stderr, "replication: flush_all malloc error\n");
+        return(-1);
+    }
+    p = c->wbuf + c->wbytes;
+    memcpy(p, s, strlen(s));
+    p += strlen(s);
+    if (exp > 0)
+        p += replication_get_num(p, exp);
+    memcpy(p, n, strlen(n));
+    p += strlen(n);
+    c->wbytes = p - c->wbuf;
+    c->wcurr  = c->wbuf;
+    return(0);
+}
+
+static int replication_marugoto_end(conn *c)
+{
+    char *s = "marugoto_end";
+    char *n = "\r\n";
+    char *p = NULL;
+
+    int l = strlen(s) + strlen(n);
+    if(replication_alloc(c,l) == -1){
+        fprintf(stderr, "replication: marugoto_end malloc error\n");
+        return(-1);
+    }
+    p = c->wbuf + c->wbytes;
+    memcpy(p, s, strlen(s));
+    p += strlen(s);
+    memcpy(p, n, strlen(n));
+    p += strlen(n);
+    c->wbytes = p - c->wbuf;
+    c->wcurr  = c->wbuf;
+    return(0);
+}
+
+int replication_cmd(conn *c, Q_ITEM *q)
+{
+    item *it;
+    int r;
+
+    switch (q->type) {
+    case REPLICATION_REP:
+        it = item_get(q->key, strlen(q->key));
+        if (!it)
+            return(replication_del(c, q->key));
+        r = replication_rep(c, it);
+        item_remove(it);
+        return r;
+    case REPLICATION_DEL:
+        return(replication_del(c, q->key));
+    case REPLICATION_FLUSH_ALL:
+        return(replication_flush_all(c, 0));
+    case REPLICATION_DEFER_FLUSH_ALL:
+        return(replication_flush_all(c, q->time));
+    case REPLICATION_MARUGOTO_END:
+        return(replication_marugoto_end(c));
+    default:
+        fprintf(stderr,"replication: got unknown command:%d\n", q->type);
+        return(0);
+    }
+}
diff -urN --exclude *.m4 memcached-1.4.4/replication.h repcached-2.2-1.4.4/replication.h
--- memcached-1.4.4/replication.h	Thu Jan  1 03:00:00 1970
+++ repcached-2.2-1.4.4/replication.h	Wed Feb 10 18:40:31 2010
@@ -0,0 +1,42 @@
+#ifndef MEMCACHED_REPLICATION_H
+#define MEMCACHED_REPLICATION_H
+#define REPCACHED_VERSION "2.2"
+#include <netdb.h>
+
+enum CMD_TYPE {
+  REPLICATION_REP,
+  REPLICATION_DEL,
+  REPLICATION_FLUSH_ALL,
+  REPLICATION_DEFER_FLUSH_ALL,
+  REPLICATION_MARUGOTO_END,
+};
+
+typedef struct queue_item_t Q_ITEM;
+struct queue_item_t {
+  enum CMD_TYPE  type;
+  char          *key;
+  rel_time_t     time;
+  Q_ITEM        *next;
+};
+
+typedef struct replication_cmd_t R_CMD;
+struct replication_cmd_t {
+  char       *key;
+  int         keylen;
+  rel_time_t  time;
+};
+
+Q_ITEM *qi_new(enum CMD_TYPE type, R_CMD *cmd, bool);
+void    qi_free(Q_ITEM *);
+int     qi_free_list(void);
+int     replication_cmd(conn *, Q_ITEM *);
+int     get_qi_count(void);
+
+int replication_call_rep(char *key, size_t keylen);
+int replication_call_del(char *key, size_t keylen);
+int replication_call_flush_all(void);
+int replication_call_defer_flush_all(const rel_time_t time);
+int replication_call_marugoto_end(void);
+int replication(enum CMD_TYPE type, R_CMD *cmd);
+
+#endif
diff -urN --exclude *.m4 memcached-1.4.4/t/binary.t repcached-2.2-1.4.4/t/binary.t
--- memcached-1.4.4/t/binary.t	Fri Nov 27 08:05:16 2009
+++ repcached-2.2-1.4.4/t/binary.t	Wed Feb 10 17:04:01 2010
@@ -2,10 +2,12 @@
 
 use strict;
 use warnings;
-use Test::More tests => 3349;
+use Test::More;
 use FindBin qw($Bin);
 use lib "$Bin/lib";
 use MemcachedTest;
+
+Test::More::plan(tests => support_replication() ? 3385 : 3349);
 
 my $server = new_memcached();
 ok($server, "started the server");
diff -urN --exclude *.m4 memcached-1.4.4/t/issue_67.t repcached-2.2-1.4.4/t/issue_67.t
--- memcached-1.4.4/t/issue_67.t	Sun Nov  1 01:44:09 2009
+++ repcached-2.2-1.4.4/t/issue_67.t	Wed Feb 10 17:50:12 2010
@@ -41,6 +41,10 @@
     my $exe = "$builddir/memcached-debug";
     croak("memcached binary doesn't exist.  Haven't run 'make' ?\n") unless -e $exe;
 
+    if (support_replication()) {
+        $args .= ' -X 0';
+    }
+
     my $childpid = fork();
 
     my $cmd = "$builddir/timedrun 10 $exe $args";
diff -urN --exclude *.m4 memcached-1.4.4/t/lib/MemcachedTest.pm repcached-2.2-1.4.4/t/lib/MemcachedTest.pm
--- memcached-1.4.4/t/lib/MemcachedTest.pm	Fri Oct 30 04:24:52 2009
+++ repcached-2.2-1.4.4/t/lib/MemcachedTest.pm	Wed Feb 10 17:53:34 2010
@@ -13,7 +13,8 @@
 
 
 @EXPORT = qw(new_memcached sleep mem_get_is mem_gets mem_gets_is mem_stats
-             supports_sasl free_port);
+             supports_sasl free_port support_replication memcached_version
+             version2num);
 
 sub sleep {
     my $n = shift;
@@ -148,6 +149,23 @@
     return 0;
 }
 
+sub support_replication {
+    my $output = `$builddir/memcached-debug -h`;
+    return 1 if $output =~ /^-x <ip_addr>/m;
+    return 0;
+}
+
+sub memcached_version {
+    my $output = `$builddir/memcached-debug -h`;
+    return $1 if $output =~ /^memcached (\d[\d\.]+)/;
+    return 0;
+}
+
+sub version2num {
+    my($major,$minor,$pl) = ($_[0] =~ /^(\d+)\.(\d+)\.(\d+)$/);
+    return $major*100**2 + $minor*100 + $pl
+}
+
 sub new_memcached {
     my ($args, $passed_port) = @_;
     my $port = $passed_port || free_port();
@@ -171,6 +189,9 @@
     }
     if ($< == 0) {
         $args .= " -u root";
+    }
+    if (support_replication() && $args !~ m/-X/) {
+        $args .= ' -X 0';
     }
 
     my $childpid = fork();
diff -urN --exclude *.m4 memcached-1.4.4/t/stats.t repcached-2.2-1.4.4/t/stats.t
--- memcached-1.4.4/t/stats.t	Thu Nov 26 03:37:49 2009
+++ repcached-2.2-1.4.4/t/stats.t	Tue Feb  9 23:13:26 2010
@@ -56,7 +56,11 @@
 my $stats = mem_stats($sock);
 
 # Test number of keys
-is(scalar(keys(%$stats)), 37, "37 stats values");
+if (! support_replication()) {
+    is(scalar(keys(%$stats)), 37, "37 stats values");
+} else {
+    is(scalar(keys(%$stats)), 40, "40 stats values");
+}
 
 # Test initial state
 foreach my $key (qw(curr_items total_items bytes cmd_get cmd_set get_hits evictions get_misses
diff -urN --exclude *.m4 memcached-1.4.4/testapp.c repcached-2.2-1.4.4/testapp.c
--- memcached-1.4.4/testapp.c	Wed Nov 25 03:40:29 2009
+++ repcached-2.2-1.4.4/testapp.c	Wed Feb 10 17:52:05 2010
@@ -300,6 +300,10 @@
         argv[arg++] = "-1";
         argv[arg++] = "-U";
         argv[arg++] = "0";
+#ifdef USE_REPLICATION
+        argv[arg++] = "-X";
+        argv[arg++] = "0";
+#endif
         /* Handle rpmbuild and the like doing this as root */
         if (getuid() == 0) {
             argv[arg++] = "-u";
